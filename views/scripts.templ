package views

// sharedAnsiUtilities contains common ANSI processing functions used across pages
templ sharedAnsiUtilities() {
	<script type="module">
		// Shared ANSI color mapping for brightening dark colors
		// Makes dark 8-bit ANSI colors more visible on dark backgrounds
		const ANSI_COLOR_BRIGHTENING_MAP = {
			// Standard ANSI colors (0-7) - brighten significantly
			'rgb(0,0,187)': 'rgb(137,180,250)',      // Dark blue ‚Üí light blue
			'rgb(0,187,0)': 'rgb(166,227,161)',      // Dark green ‚Üí light green
			'rgb(187,0,187)': 'rgb(243,139,168)',    // Dark magenta ‚Üí light magenta
			'rgb(187,0,0)': 'rgb(252,165,165)',      // Dark red ‚Üí light red
			'rgb(187,187,0)': 'rgb(253,224,71)',     // Dark yellow ‚Üí bright yellow
			'rgb(0,187,187)': 'rgb(137,220,235)',    // Dark cyan ‚Üí light cyan
			// Bright ANSI colors (8-15) - improve contrast
			'rgb(85,85,85)': 'rgb(163,163,163)',     // Bright black (gray) ‚Üí lighter gray
			'rgb(255,85,85)': 'rgb(252,165,165)',    // Bright red ‚Üí softer red
			'rgb(85,255,85)': 'rgb(134,239,172)',    // Bright green ‚Üí softer green
			'rgb(255,255,85)': 'rgb(253,224,71)',    // Bright yellow ‚Üí softer yellow
			'rgb(85,85,255)': 'rgb(147,197,253)',    // Bright blue ‚Üí softer blue
			'rgb(255,85,255)': 'rgb(244,114,182)',   // Bright magenta ‚Üí softer magenta
			'rgb(85,255,255)': 'rgb(165,243,252)'    // Bright cyan ‚Üí softer cyan
		};

		// Shared function to brighten ANSI colors
		window.brightenAnsiColors = function(html) {
			let result = html;
			for (const [dark, light] of Object.entries(ANSI_COLOR_BRIGHTENING_MAP)) {
				// Escape special regex characters in color values
				const escaped = dark.replace(/[()]/g, '\\$&');
				result = result.replace(new RegExp(escaped, 'g'), light);
			}
			return result;
		};
	</script>
}

// indexPageInlineScript contains the inline JavaScript for IndexPage (AnsiUp setup)
templ indexPageInlineScript() {
	@sharedAnsiUtilities()
	<script type="module">
			import { AnsiUp } from 'https://cdn.jsdelivr.net/npm/ansi_up@6/ansi_up.js';
			const ansiUp = new AnsiUp();
			ansiUp.escapeHtml = true;

			// Convert ANSI to HTML with brightening (uses shared brightenAnsiColors)
			window.ansiToHtml = function(text) {
				// Convert tmux's visible ESC symbol (‚êõ, U+241B) to real ESC byte
				text = text.replace(/\u241b/g, '\x1b');
				let html = ansiUp.ansi_to_html(text);
				// Strip any orphaned ANSI codes that survived (ESC lost in transmission)
				html = html.replace(/\[[0-9;]*m/g, '');
				return window.brightenAnsiColors(html);
			};
	</script>
}

templ paneScripts() {
	<script>
		// Theme support - must run synchronously before render
		(function() {
			const saved = localStorage.getItem('houston-theme');
			if (saved === 'light') {
				document.documentElement.setAttribute('data-theme', 'light');
			} else if (!saved && window.matchMedia('(prefers-color-scheme: light)').matches) {
				document.documentElement.setAttribute('data-theme', 'light');
			}
		})();
	</script>
	@sharedAnsiUtilities()
	<script type="module">
		import { AnsiUp } from 'https://cdn.jsdelivr.net/npm/ansi_up@6/ansi_up.js';

		const ansiUp = new AnsiUp();
		ansiUp.escapeHtml = true;  // Ensure HTML is escaped (v6 uses camelCase)

		// Strip ANSI background colors from ansi_up output
		// Only target rgb() values (ansi_up uses rgb, not rgba) to avoid stripping CSS code in terminal content
		function fixBackgrounds(html) {
			html = html.replace(/background-color:\s*rgb\([^)]+\);?/gi, '');
			return html;
		}

		// Add subtle backgrounds for diff lines
		// Claude Code format: "703 +  code" or "703 -  code" (line number, space, +/-, space, code)
		function enhanceDiffs(html) {
			const lines = html.split('\n');
			return lines.map(line => {
				const stripped = line.replace(/<[^>]*>/g, ''); // Strip HTML tags to check content
				// Match Claude Code diff format: line_number +/- code
				const match = stripped.match(/^\s*\d+\s+([-+])\s/);
				if (match) {
					if (match[1] === '+') {
						return '<span class="diff-add">' + line + '</span>';
					} else {
						return '<span class="diff-del">' + line + '</span>';
					}
				}
				// Also match standard diff format (starts with +/- directly)
				if (stripped.startsWith('+') && !stripped.startsWith('+++')) {
					return '<span class="diff-add">' + line + '</span>';
				} else if (stripped.startsWith('-') && !stripped.startsWith('---')) {
					return '<span class="diff-del">' + line + '</span>';
				} else if (stripped.startsWith('@@')) {
					return '<span class="diff-hunk">' + line + '</span>';
				}
				return line;
			}).join('\n');
		}

		// Highlight user input lines with subtle background
		function highlightUserInput(html) {
			const lines = html.split('\n');
			let inUserInput = false;
			return lines.map(line => {
				const stripped = line.replace(/<[^>]*>/g, ''); // Strip HTML tags to check content
				const trimmed = stripped.trim();

				// Check if this is a prompt line (starts with >)
				if (/^\s*>/.test(stripped)) {
					inUserInput = true;
					return '<span class="user-input">' + line + '</span>';
				}

				// Check if this is a horizontal separator (ends user input block)
				if (/^[\s‚îÄ]{20,}$/.test(stripped)) {
					inUserInput = false;
					return line;
				}

				// Check if this is an indented continuation of user input
				// (starts with spaces and we're in user input mode)
				if (inUserInput && /^\s{2,}/.test(stripped) && trimmed.length > 0) {
					return '<span class="user-input">' + line + '</span>';
				}

				// Empty line might continue user input block
				if (inUserInput && trimmed.length === 0) {
					return line;
				}

				// Any non-indented content ends user input block
				if (trimmed.length > 0 && !/^\s{2,}/.test(stripped)) {
					inUserInput = false;
				}

				return line;
			}).join('\n');
		}

		function processOutput(text) {
			try {
				// Normalize line endings and remove carriage returns
				text = text.replace(/\r\n/g, '\n').replace(/\r/g, '');
				
				// Extract OSC 8 hyperlinks BEFORE ansi_up (which escapes HTML)
				// Store them with placeholders, restore after
				const links = [];
				text = extractOSC8Links(text, links);
				
				let html = ansiUp.ansi_to_html(text);
				// Brighten dark ANSI colors for better visibility (uses shared function)
				html = window.brightenAnsiColors(html);
				html = highlightUserInput(html);
				
				// Restore OSC 8 links as HTML
				html = restoreOSC8Links(html, links);
				
				return html;
			} catch (err) {
				console.error('ansi_up error:', err);
				// Fallback: escape HTML and preserve newlines
				return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
			}
		}
		
		// Extract OSC 8 links and replace with placeholders
		function extractOSC8Links(text, links) {
			// OSC 8 format: \x1b]8;id=xxx;url\x1b\\visible_text\x1b]8;;\x1b\\
			// Or with \x07 (BEL) as terminator
			const osc8Pattern = /\x1b\]8;([^;]*);([^\x1b\x07]*?)(?:\x1b\\|\x07)(.*?)\x1b\]8;;(?:\x1b\\|\x07)/g;
			
			return text.replace(osc8Pattern, (match, params, url, linkText) => {
				const placeholder = `__OSC8LINK_${links.length}__`;
				links.push({ url, text: linkText });
				return placeholder;
			});
		}
		
		// Restore OSC 8 links from placeholders to HTML
		function restoreOSC8Links(html, links) {
			// Pattern for visible ANSI escape symbols (tmux sometimes uses ‚êõ instead of \x1b)
			const visibleAnsiPattern = /‚êõ\[[0-9;]*[a-zA-Z]/g;
			
			for (let i = 0; i < links.length; i++) {
				let { url, text } = links[i];
				// Strip any visible ANSI sequences from link text
				text = text.replace(visibleAnsiPattern, '');
				const placeholder = `__OSC8LINK_${i}__`;
				// Only allow http/https URLs to prevent javascript: XSS
				const safeUrl = url.startsWith('http://') || url.startsWith('https://') ? url : '#';
				const link = `<a href="${safeUrl}" class="terminal-link" target="_blank">${text}</a>`;
				html = html.replace(placeholder, link);
			}
			return html;
		}

		document.addEventListener('DOMContentLoaded', function() {
			const container = document.getElementById('output-container');
			if (container) {
				container.scrollTop = container.scrollHeight;
			}
			const output = document.getElementById('output');
			if (output) {
				const text = output.textContent;
				output.innerHTML = processOutput(text);
				// Check for pending input on initial load
				updatePendingInput(text);
			}
		});

		// Track current vim mode (persists across SSE messages)
		let currentVimMode = '';
		
		// Track current agent type for scroll behavior
		let currentAgentType = 'generic';
		
		// Send scroll keys to Amp (called from scroll buttons)
		window.ampScroll = function(direction) {
			const container = document.getElementById('output-container');
			const paneTarget = container?.getAttribute('data-pane-target');
			if (!paneTarget) return;
			
			// Dim container until SSE refreshes (with fallback timeout)
			container.classList.add('scrolling');
			setTimeout(() => container.classList.remove('scrolling'), 2000);
			
			const key = direction === 'up' ? 'PPage' : 'NPage';
			fetch(`/pane/${paneTarget}/send`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: `input=${key}&special=true`
			}).catch(err => console.error('Scroll send failed:', err));
		};

		// Handle SSE messages manually to prevent htmx from setting innerHTML directly
		// This prevents terminal content with HTML-like text from being rendered as actual HTML
		document.body.addEventListener('htmx:sseMessage', function(e) {
			console.debug('SSE message received', e.detail.data?.length || 0, 'bytes');
			const output = document.getElementById('output');
			if (!output) return;

			const container = document.getElementById('output-container');
			// Check if user is at the bottom before updating (with 50px threshold)
			const wasAtBottom = container &&
				(container.scrollTop + container.clientHeight >= container.scrollHeight - 50);

			// Get the raw text from SSE (already safe as plain text)
			let text = e.detail.data;

			// Track current mode, agent type, and Claude mode for status indicators
			let currentMode = '';
			let currentAgent = 'generic';
			let claudeModeData = {};

			// Extract mode from special first line if present
			const modeMatch = text.match(/^__MODE__:(\w*)\n/);
			if (modeMatch) {
				currentMode = modeMatch[1];
				currentVimMode = currentMode; // Persist for form submission
				text = text.substring(modeMatch[0].length);
				updateModeIndicatorDirect(currentMode);
			}

			// Extract agent type if present
			const agentMatch = text.match(/^__AGENT__:([^\n]*)\n/);
			if (agentMatch) {
				currentAgent = agentMatch[1] || 'generic';
				currentAgentType = currentAgent; // Update global for scroll handling
				text = text.substring(agentMatch[0].length);
				// Store agent type for choice handling
				const bar = document.getElementById('choices-bar');
				if (bar) bar.dataset.agentType = currentAgent;
			}

			// Extract choices from special line if present
			const choicesMatch = text.match(/^__CHOICES__:([^\n]*)\n/);
			if (choicesMatch) {
				const choicesStr = choicesMatch[1];
				text = text.substring(choicesMatch[0].length);
				updateChoices(choicesStr ? choicesStr.split('|') : [], currentAgent);
			}

			// Extract Claude mode state if present (JSON)
			const claudeModeMatch = text.match(/^__CLAUDEMODE__:([^\n]*)\n/);
			if (claudeModeMatch) {
				text = text.substring(claudeModeMatch[0].length);
				try {
					claudeModeData = JSON.parse(claudeModeMatch[1] || '{}');
					updateClaudeMode(claudeModeData);
				} catch (e) {
					console.warn('Failed to parse Claude mode:', e);
				}
			}

			// Extract status line with ANSI colors (newlines encoded as ‚êä)
			const statusLineMatch = text.match(/^__STATUSLINE__:([^\n]*)\n/);
			let rawStatusLine = '';
			if (statusLineMatch) {
				// Restore newlines from placeholder
				rawStatusLine = statusLineMatch[1].replace(/‚êä/g, '\n');
				text = text.substring(statusLineMatch[0].length);
			}

			// Extract structured Amp status
			const ampStatusMatch = text.match(/^__AMPSTATUS__:(\{[^\n]*\})\n/);
			if (ampStatusMatch) {
				text = text.substring(ampStatusMatch[0].length);
				try {
					const ampStatus = JSON.parse(ampStatusMatch[1]);
					updateAmpStatus(ampStatus);
				} catch (e) {
					console.warn('Failed to parse Amp status:', e, ampStatusMatch[1]);
				}
			}

			// Extract prompt suggestion (try anchored first, fallback to search anywhere)
			let suggestionMatch = text.match(/^__SUGGESTION__:([^\n]*)\n/);
			if (suggestionMatch) {
				text = text.substring(suggestionMatch[0].length);
			} else {
				// Fallback: find __SUGGESTION__ anywhere in text (in case previous extractions shifted position)
				const idx = text.indexOf('__SUGGESTION__:');
				if (idx !== -1) {
					const end = text.indexOf('\n', idx);
					if (end !== -1) {
						suggestionMatch = [text.substring(idx, end + 1), text.substring(idx + '__SUGGESTION__:'.length, end)];
						text = text.substring(0, idx) + text.substring(end + 1);
					}
				}
			}
			if (suggestionMatch) {
				console.debug('SSE suggestion:', JSON.stringify(suggestionMatch[1]));
				updateSuggestion(suggestionMatch[1] || '');
			}

			if (currentAgent === 'claude-code' && rawStatusLine) {
				// For Claude Code, show raw status line
				updateClaudeStatusLine(rawStatusLine);
			}

			// Update mode indicators (combines mode + claudeMode state)
			updateModeIndicators(currentMode, claudeModeData);

			// Process with ansi_up (which has escapeHtml enabled)
			output.innerHTML = processOutput(text);

			// Update pending input bar
			updatePendingInput(text);

			// Only auto-scroll if user was already at the bottom
			if (wasAtBottom && container) {
				container.scrollTop = container.scrollHeight;
			}
			
			// Clear scroll dimming (from Amp scroll buttons)
			if (container) {
				container.classList.remove('scrolling');
			}
		});

		// Update choices bar dynamically
		function updateChoices(choices, agentType) {
			const bar = document.getElementById('choices-bar');
			if (!bar) return;

			if (!choices || choices.length === 0 || (choices.length === 1 && choices[0] === '')) {
				bar.classList.add('hidden');
				bar.innerHTML = '';
				return;
			}

			const isAmp = agentType === 'amp';
			bar.classList.remove('hidden');
			let html = '';
			choices.forEach((choice, i) => {
				const num = i + 1;
				const shortChoice = choice.length > 20 ? choice.substring(0, 17) + '...' : choice;
				// For Amp, store index for arrow navigation; for Claude, use number
				html += `<button class="choice-btn" data-choice="${num}" data-choice-index="${i}" data-choice-text="${escapeHtml(choice)}">
					<span class="choice-num">${isAmp ? '‚Üì' + i : num}</span>
					<span class="choice-text">${escapeHtml(shortChoice)}</span>
				</button>`;
			});
			bar.innerHTML = html;
		}

		function escapeHtml(text) {
			const div = document.createElement('div');
			div.textContent = text;
			return div.innerHTML;
		}

		// Send choice to pane
		window.sendChoice = async function(num, choiceText, choiceIndex) {
			const bar = document.getElementById('choices-bar');
			if (!bar) return;
			const target = bar.dataset.paneTarget;
			const agentType = bar.dataset.agentType || 'generic';
			if (!target) return;

			// Visual feedback - disable all choice buttons during send
			const buttons = bar.querySelectorAll('.choice-btn');
			const clickedBtn = bar.querySelector(`[data-choice="${num}"]`);
			buttons.forEach(btn => btn.disabled = true);
			if (clickedBtn) {
				clickedBtn.classList.add('sending');
				clickedBtn.querySelector('.choice-num').textContent = '...';
			}

			try {
				if (agentType === 'amp') {
					// Amp uses cursor navigation: send Down arrows then Enter
					// First choice (index 0) is already selected, just send Enter
					await sendAmpChoice(target, choiceIndex);
				} else {
					// Claude uses numbers
					const response = await fetch(`/pane/${target}/send`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
						body: `input=${num}&noenter=true`
					});
					if (!response.ok) {
						throw new Error(`Send failed: ${response.status}`);
					}
				}

				// If choice says "Type here" or similar, focus input for custom response
				if (choiceText && choiceText.toLowerCase().includes('type')) {
					setTimeout(() => {
						const inputField = document.getElementById('input-field');
						if (inputField) {
							inputField.focus();
						}
					}, 100);
				}
			} catch (err) {
				console.error('Failed to send choice:', err);
				// Re-enable buttons on error
				buttons.forEach(btn => btn.disabled = false);
				if (clickedBtn) {
					clickedBtn.classList.remove('sending');
					clickedBtn.querySelector('.choice-num').textContent = num;
				}
				alert('Failed to send choice. Please try again.');
			}
		}

		// Send Amp choice using arrow navigation
		async function sendAmpChoice(target, index) {
			// Send Down arrow 'index' times, then Enter
			for (let i = 0; i < index; i++) {
				const response = await fetch(`/pane/${target}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: 'input=Down&special=true'
				});
				if (!response.ok) {
					throw new Error(`Failed to send Down key: ${response.status}`);
				}
				// Small delay between key presses for terminal to process
				await new Promise(r => setTimeout(r, 50));
			}
			// Send Enter to confirm
			const response = await fetch(`/pane/${target}/send`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: 'input=Enter&special=true'
			});
			if (!response.ok) {
				throw new Error(`Failed to send Enter key: ${response.status}`);
			}
		}

		// Event delegation for choice buttons (avoids HTML entity escaping issues in onclick)
		document.addEventListener('click', function(e) {
			const choiceBtn = e.target.closest('.choice-btn');
			if (choiceBtn) {
				e.stopPropagation();
				const num = choiceBtn.dataset.choice;
				const text = choiceBtn.dataset.choiceText;
				const index = parseInt(choiceBtn.dataset.choiceIndex || '0', 10);
				if (num) {
					sendChoice(num, text, index);
				}
			}
		});

		// Log SSE connection events
		document.body.addEventListener('htmx:sseOpen', function(e) {
			console.log('SSE connected');
		});

		document.body.addEventListener('htmx:sseError', function(e) {
			console.warn('SSE error', e.detail);
		});

		// Update mode indicator based on mode string from server
		function updateModeIndicatorDirect(mode) {
			const modeEl = document.getElementById('mode-indicator');
			if (!modeEl) return;

			if (mode === 'insert') {
				modeEl.textContent = 'INS';
				modeEl.className = 'text-xs px-2 py-1 bg-green-600 text-white rounded font-medium shadow-sm';
			} else {
				modeEl.textContent = 'NOR';
				modeEl.className = 'text-xs px-2 py-1 bg-blue-600 text-white rounded font-medium shadow-sm';
			}
		}

		// Fallback: Update mode indicator by parsing text (for initial page load)
		function updateModeIndicator(text) {
			const modeEl = document.getElementById('mode-indicator');
			if (!modeEl) return;

			// Check last few lines for INSERT mode
			const lines = text.split('\n').slice(-10).join('\n');
			const isInsert = lines.includes('-- INSERT --');

			if (isInsert) {
				modeEl.textContent = 'INS';
				modeEl.className = 'text-xs px-2 py-1 bg-green-600 text-white rounded font-medium shadow-sm';
			} else {
				modeEl.textContent = 'NOR';
				modeEl.className = 'text-xs px-2 py-1 bg-blue-600 text-white rounded font-medium shadow-sm';
			}
		}

		window.toggleMenu = function() {
			document.getElementById('menu').classList.toggle('hidden');
		}

		window.scrollToTop = function() {
			document.getElementById('output-container').scrollTop = 0;
			document.getElementById('menu').classList.add('hidden');
		}

		// Click on prompt pattern to focus input field
		// Detects: ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ separator lines and > prompt lines
		window.handleOutputClick = function(e) {
			// Don't interfere with text selection
			if (window.getSelection().toString()) return;

			// Get the text at click position
			let clickedLine = '';

			// Try to get the line that was clicked
			if (document.caretRangeFromPoint) {
				const range = document.caretRangeFromPoint(e.clientX, e.clientY);
				if (range && range.startContainer) {
					const text = range.startContainer.textContent || '';
					// Get the line containing the click position
					const lines = text.split('\n');
					let pos = 0;
					for (const line of lines) {
						if (pos + line.length >= range.startOffset) {
							clickedLine = line;
							break;
						}
						pos += line.length + 1;
					}
				}
			}

			// Check if clicked line is a prompt pattern
			const isPromptLine = (
				clickedLine.match(/^\s*>{1,3}\s*/) ||            // > or >>> (with optional text)
				clickedLine.match(/^[‚îÄ‚îÅ\-]{5,}/)                 // Separator line (‚îÄ‚îÄ‚îÄ‚îÄ)
			);

			if (isPromptLine) {
				document.getElementById('input-field').focus();
			}
		}

		// Strip ANSI escape codes from text
		function stripAnsi(text) {
			return text.replace(/\x1b\[[0-9;]*m/g, '');
		}

		// Extract pending input from Claude's prompt line(s)
		// Claude Code shows: ">" or ">>>" followed by user's typed text
		// Multi-line input shows continuation lines after the first prompt
		function extractPendingInput(text) {
			const lines = text.split('\n');
			const pendingLines = [];
			let foundPrompt = false;

			// Scan from bottom up to find prompt area
			for (let i = lines.length - 1; i >= Math.max(0, lines.length - 20); i--) {
				const line = lines[i];

				// Match prompt line: > or >>> with optional text
				// Allow ANSI escape codes before the prompt (e.g., \u001b[0m>)
				const promptMatch = line.match(/^(?:\x1b\[[0-9;]*m)*\s*(>{1,3})\s*(.*)$/);

				if (promptMatch) {
					foundPrompt = true;
					let content = stripAnsi(promptMatch[2]); // Strip ANSI codes from content
					// Remove pasted text indicators like "[Pasted text #1 +10 lines]"
					content = content.replace(/\[Pasted text #\d+ \+\d+.*?\]/g, '').trim();
					if (content) {
						pendingLines.unshift(content); // Add to front (we're going backwards)
					}
				} else if (foundPrompt) {
					// We found prompts but this line doesn't have one
					let trimmed = stripAnsi(line.trim());
					// Stop if we hit a separator, empty line, or status bar content
					if (!trimmed || trimmed.match(/^[‚îÄ‚îÅ\-]{5,}/) ||
						trimmed.includes('-- INSERT --') || trimmed.includes('-- NORMAL --')) {
						break;
					}
					// Skip pasted text indicator lines
					if (trimmed.match(/^\[Pasted text #\d+/)) {
						continue;
					}
					// Check if this might be a continuation line (no prompt, just content)
					// Claude wraps long input, so continuation lines are possible
					// But stop if we hit obvious non-prompt content
					if (trimmed.startsWith('‚îÇ') || trimmed.startsWith('‚éø') ||
						trimmed.startsWith('‚óè') || trimmed.startsWith('‚úª')) {
						break;
					}
					// This could be wrapped input text, add it
					pendingLines.unshift(trimmed);
				}
			}

			if (pendingLines.length === 0) {
				return foundPrompt ? '' : null; // Empty prompt vs no prompt
			}

			return pendingLines.join('\n');
		}

		// Update pending input bar based on output
		function updatePendingInput(text) {
			const pendingBar = document.getElementById('pending-input-bar');
			const pendingText = document.getElementById('pending-input-text');
			if (!pendingBar || !pendingText) return;

			const pending = extractPendingInput(text);
			if (pending && pending.length > 0) {
				// Show first line + indicator if multi-line
				const lines = pending.split('\n');
				let display = lines[0];
				if (lines.length > 1) {
					display += ` (+${lines.length - 1} more)`;
				}
				pendingText.textContent = display;
				pendingText.title = pending; // Full text on hover
				pendingBar.classList.remove('hidden');
			} else {
				pendingBar.classList.add('hidden');
			}
		}

		// Track whether user dismissed the current suggestion
		let suggestionDismissed = false;
		// Initialize from server-rendered suggestion (if any)
		let currentSuggestion = document.getElementById('suggestion-text')?.textContent || '';

		// Update suggestion bar from SSE data
		function updateSuggestion(text) {
			const bar = document.getElementById('suggestion-bar');
			const textEl = document.getElementById('suggestion-text');
			if (!bar || !textEl) {
				console.warn('Suggestion bar elements not found');
				return;
			}

			if (!text) {
				// Empty suggestion from SSE (CC working or no suggestion)
				// Don't hide - keep showing the last suggestion until user acts
				return;
			}

			// New suggestion text arrived
			if (text !== currentSuggestion) {
				// Different suggestion - reset dismissal, show it
				currentSuggestion = text;
				suggestionDismissed = false;
			}

			if (suggestionDismissed) {
				console.debug('Suggestion dismissed, not showing');
				return;
			}

			textEl.textContent = text;
			textEl.title = text;
			bar.classList.remove('hidden');
			console.debug('Suggestion bar shown:', text.substring(0, 40));
		}

		// Pre-fill input with suggestion text
		window.useSuggestion = function() {
			const textEl = document.getElementById('suggestion-text');
			const inputField = document.getElementById('input-field');
			if (!textEl || !inputField) return;

			inputField.value = textEl.title || textEl.textContent;
			autoResize(inputField);
			inputField.focus();
			document.getElementById('suggestion-bar')?.classList.add('hidden');
		}

		// Send suggestion directly
		window.sendSuggestion = function() {
			const textEl = document.getElementById('suggestion-text');
			const paneTarget = document.getElementById('output-container')?.getAttribute('data-pane-target');
			if (!textEl || !paneTarget) return;

			const text = textEl.title || textEl.textContent;
			if (!text) return;

			document.getElementById('suggestion-bar')?.classList.add('hidden');
			suggestionDismissed = true;
			currentSuggestion = '';

			// Switch to INSERT mode if needed
			const modeSwitch = currentVimMode === 'normal'
				? fetch(`/pane/${paneTarget}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: 'input=i&noenter=true'
				}).then(() => new Promise(r => setTimeout(r, 50)))
				: Promise.resolve();

			modeSwitch.then(() => {
				fetch(`/pane/${paneTarget}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: `input=${encodeURIComponent(text)}`
				});
			});
		}

		// Dismiss suggestion
		window.dismissSuggestion = function() {
			document.getElementById('suggestion-bar')?.classList.add('hidden');
			suggestionDismissed = true;
			currentSuggestion = '';
		}

		// Edit pending input - copy to input field for editing
		window.editPendingInput = function() {
			const pendingText = document.getElementById('pending-input-text');
			const inputField = document.getElementById('input-field');
			if (!pendingText || !inputField) return;

			// Get full text from title attribute (textContent may be truncated)
			const fullText = pendingText.title || pendingText.textContent;
			if (fullText) {
				// Only fill input field if it's empty (don't overwrite user input)
				if (inputField.value.trim() === '') {
					inputField.value = fullText;
					autoResize(inputField);
				}
				inputField.focus();

				// Clear the existing input in Claude (send Ctrl+U to clear line)
				const bar = document.getElementById('choices-bar');
				const target = bar?.dataset.paneTarget;
				if (target) {
					fetch(`/pane/${target}/send`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
						body: 'input=C-u&special=true'
					});
				}
			}
		}

		// Clear pending input in Claude
		window.clearPendingInput = function() {
			const bar = document.getElementById('choices-bar');
			const target = bar?.dataset.paneTarget;
			if (target) {
				// Send Ctrl+U to clear the line
				fetch(`/pane/${target}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: 'input=C-u&special=true'
				});
			}
		}

		// Toggle auto-accept edits (sends Shift+Tab)
		window.toggleAutoAccept = function() {
			const target = document.getElementById('output-container')?.getAttribute('data-pane-target');
			console.log('toggleAutoAccept called, target:', target);
			if (target) {
				fetch(`/pane/${target}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: 'input=BTab&special=true'
				}).then(r => console.log('toggle response:', r.status));
			} else {
				console.warn('No pane target found for toggle');
			}
		}

		// Update Claude mode indicator (dynamic - shows whatever mode is active)
		function updateClaudeMode(mode) {
			const toggle = document.getElementById('autoaccept-toggle');
			const iconEl = toggle?.querySelector('.autoaccept-icon');
			const stateEl = document.getElementById('autoaccept-state');
			if (!toggle || !stateEl || !iconEl) return;

			toggle.classList.remove('on', 'off');
			if (mode.state === 'on') {
				toggle.classList.add('on');
				iconEl.textContent = mode.icon || '‚èµ‚èµ';
				stateEl.textContent = 'on';
				toggle.title = `${mode.label || 'Mode'} on (Shift+Tab to cycle)`;
			} else if (mode.state === 'off') {
				toggle.classList.add('off');
				iconEl.textContent = mode.icon || '‚èµ‚èµ';
				stateEl.textContent = 'off';
				toggle.title = `${mode.label || 'Mode'} off (Shift+Tab to cycle)`;
			} else {
				// No mode detected
				iconEl.textContent = '‚èµ‚èµ';
				stateEl.textContent = '--';
				toggle.title = 'Toggle mode (Shift+Tab)';
			}
		}

		// Toggle status section visibility (close button hides it)
		window.toggleStatusSection = function() {
			const section = document.getElementById('status-section');
			section?.classList.remove('visible');
			localStorage.setItem('statusSectionVisible', 'false');
		}

		// Update Amp status display from structured data
		function updateAmpStatus(status) {
			const section = document.getElementById('status-section');
			const ctxEl = document.getElementById('status-context-value');
			const costEl = document.getElementById('status-cost-value');
			const modeEl = document.getElementById('status-mode-value');

			if (!ctxEl) return;

			// Update context usage (e.g., "27% of 168k")
			if (status.tokenPercent && status.tokenLimit) {
				ctxEl.textContent = `${status.tokenPercent} of ${status.tokenLimit}`;
			} else if (status.tokenPercent) {
				ctxEl.textContent = status.tokenPercent;
			}

			// Update cost (e.g., "$0.63" or "$0.63 (free)")
			if (status.cost) {
				costEl.textContent = status.costNote ? `${status.cost} ${status.costNote}` : status.cost;
			}

			// Update mode (e.g., "smart", "rush", "auto")
			if (status.mode) {
				modeEl.textContent = status.mode;
			}

			// Show Amp bar, hide Claude bar
			document.getElementById('status-bar-amp')?.classList.remove('hidden');
			document.getElementById('status-bar-claude')?.classList.add('hidden');

			// Auto-show if we have data
			const hasData = status.tokenPercent || status.cost || status.mode;
			if (hasData) {
				const shouldShow = localStorage.getItem('statusSectionVisible') !== 'false';
				if (shouldShow) {
					section.classList.add('visible');
				}
			} else {
				section.classList.remove('visible');
			}
		}

		// Update Claude Code status line (two columns: left scrollable, right fixed)
		function updateClaudeStatusLine(statusLine) {
			const section = document.getElementById('status-section');
			const leftEl = document.getElementById('status-line-left');
			const rightEl = document.getElementById('status-line-right');
			if (!leftEl) return;

			// Helper to convert ANSI and fix colors
			function processLine(line) {
				let html = ansiUp.ansi_to_html(line);
				html = html.replace(/rgb\(0,0,187\)/g, 'rgb(137,180,250)');
				html = html.replace(/rgb\(0,187,0\)/g, 'rgb(166,227,161)');
				html = html.replace(/rgb\(187,0,187\)/g, 'rgb(243,139,168)');
				html = html.replace(/rgb\(187,0,0\)/g, 'rgb(243,139,168)');
				html = html.replace(/rgb\(187,187,0\)/g, 'rgb(249,226,175)');
				html = html.replace(/rgb\(0,187,187\)/g, 'rgb(137,220,235)');
				// Strip mode indicators
				html = html.replace(/--\s+INSERT\s+--.*$/, '');
				html = html.replace(/‚èµ‚èµ\s+accept edits.*$/, '');
				html = html.replace(/‚è∏\s+plan mode.*$/, '');
				return html.trim();
			}

			// Parse status line into left (main info) and right (notifications) columns
			// This is best-effort - if parsing fails, everything goes to left
			const lines = statusLine.split('\n').filter(l => l.trim() !== '');
			let leftParts = [];
			let rightParts = [];

			try {
				// Pattern for CC notifications that should go to right side
				// These are specific alert messages, not regular status info
				const notificationPattern = /Context left|auto-compact|compacting/i;

				for (const line of lines) {
					// Try to split on 3+ consecutive spaces (terminal column separator)
					const parts = line.split(/\s{3,}/).filter(p => p.trim());
					
					for (const part of parts) {
						const processed = processLine(part);
						if (!processed) continue;
						
						// Only specific notifications go to right
						if (notificationPattern.test(part)) {
							rightParts.push(processed);
						} else {
							leftParts.push(processed);
						}
					}
				}
			} catch (e) {
				// Fallback: show everything in left column
				console.warn('Status line parsing failed:', e);
				leftParts = lines.map(l => processLine(l)).filter(p => p);
				rightParts = [];
			}

			leftEl.innerHTML = leftParts.join(' ¬∑ ') || '';
			if (rightEl) rightEl.innerHTML = rightParts.join(' ¬∑ ') || '';

			// Show Claude bar, hide Amp bar
			document.getElementById('status-bar-amp')?.classList.add('hidden');
			document.getElementById('status-bar-claude')?.classList.remove('hidden');

			// Auto-show if we have content
			if (statusLine && statusLine.trim() !== '') {
				const shouldShow = localStorage.getItem('statusSectionVisible') !== 'false';
				if (shouldShow) {
					section.classList.add('visible');
				}
			} else {
				section.classList.remove('visible');
			}
		}

		// Update mode indicators based on current state
		function updateModeIndicators(mode, claudeMode) {
			const acceptEl = document.getElementById('accept-indicator');
			const planEl = document.getElementById('plan-indicator');

			// Accept edits indicator
			if (claudeMode.label === 'accept edits' && claudeMode.state === 'on') {
				acceptEl?.classList.remove('hidden');
			} else {
				acceptEl?.classList.add('hidden');
			}

			// Plan mode indicator
			if (claudeMode.label === 'plan mode' && claudeMode.state === 'on') {
				planEl?.classList.remove('hidden');
			} else {
				planEl?.classList.add('hidden');
			}
		}

		// Cycle Claude modes by sending Shift+Tab to tmux
		window.cycleClaudeMode = function() {
			const paneTarget = document.getElementById('output-container')?.getAttribute('data-pane-target');
			if (!paneTarget) return;

			fetch(`/pane/${paneTarget}/send`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: 'input=BTab&special=true'
			}).then(response => {
				if (!response.ok) console.error('Failed to cycle Claude mode');
			});
		}

		// Cycle Amp modes by sending Ctrl+Shift+M
		window.cycleAmpMode = function() {
			const paneTarget = document.getElementById('output-container')?.getAttribute('data-pane-target');
			if (!paneTarget) return;

			// Amp uses Ctrl+Shift+M to cycle modes (smart -> rush -> auto)
			fetch(`/pane/${paneTarget}/send`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: 'input=M-m&special=true'
			}).then(response => {
				if (!response.ok) console.error('Failed to cycle Amp mode');
			});
		}

		// Restore visibility on page load
		document.addEventListener('DOMContentLoaded', function() {
			const shouldShow = localStorage.getItem('statusSectionVisible') !== 'false';
			if (shouldShow) {
				document.getElementById('status-section')?.classList.add('visible');
				const btn = document.querySelector('#status-section .status-toggle-btn');
				if (btn) btn.textContent = 'Hide';
			}
		});

		// Terminal font size control (calls host terminal via houston API)
		window.fontIncrease = function() {
			fetch('/font/increase', { method: 'POST' })
				.then(r => { if (!r.ok) console.error('Font increase failed'); })
				.catch(e => console.error('Font increase error:', e));
		}

		window.fontDecrease = function() {
			fetch('/font/decrease', { method: 'POST' })
				.then(r => { if (!r.ok) console.error('Font decrease failed'); })
				.catch(e => console.error('Font decrease error:', e));
		}

		window.fontReset = function() {
			fetch('/font/reset', { method: 'POST' })
				.then(r => { if (!r.ok) console.error('Font reset failed'); })
				.catch(e => console.error('Font reset error:', e));
		}

		// Handle multiple image attachments
		let selectedImages = [];

		function updateAttachmentsUI() {
			const attachmentsArea = document.getElementById('attachments-area');
			if (!attachmentsArea) return;

			if (selectedImages.length === 0) {
				attachmentsArea.classList.add('hidden');
				attachmentsArea.innerHTML = '';
			} else {
				attachmentsArea.classList.remove('hidden');
				attachmentsArea.innerHTML = selectedImages.map((img, index) => `
					<div class="attachment-pill">
						<span class="attachment-name" title="${img.name}">üìé ${img.name}</span>
						<button type="button" class="attachment-remove" onclick="removeAttachment(${index})" title="Remove">
							<svg width="12" height="12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M6 18L18 6M6 6l12 12"></path>
							</svg>
						</button>
					</div>
				`).join('');
			}
		}

		window.removeAttachment = function(index) {
			selectedImages.splice(index, 1);
			updateAttachmentsUI();
		};

		window.handleImageSelect = function(event) {
			const files = event.target.files;
			if (!files || files.length === 0) return;

			// Process all selected files
			Array.from(files).forEach(file => {
				const reader = new FileReader();
				reader.onload = function(e) {
					selectedImages.push({
						name: file.name,
						type: file.type,
						data: e.target.result.split(',')[1] // base64 data without prefix
					});
					updateAttachmentsUI();
				};
				reader.readAsDataURL(file);
			});

			// Clear file input to allow selecting the same file again
			event.target.value = '';
		};

		// Handle image paste
		document.addEventListener('DOMContentLoaded', function() {
			const inputField = document.getElementById('input-field');
			if (inputField) {
				inputField.addEventListener('paste', function(e) {
					const items = e.clipboardData?.items;
					if (!items) return;

					// Look for images in clipboard
					let foundImage = false;
					for (let i = 0; i < items.length; i++) {
						if (items[i].type.indexOf('image') !== -1) {
							if (!foundImage) {
								e.preventDefault(); // Prevent default paste behavior for images
								foundImage = true;
							}

							const blob = items[i].getAsFile();
							if (!blob) continue;

							// Generate filename with timestamp
							const ext = blob.type.split('/')[1] || 'png';
							const filename = `pasted-image-${Date.now()}.${ext}`;

							// Convert to base64
							const reader = new FileReader();
							reader.onload = function(event) {
								selectedImages.push({
									name: filename,
									type: blob.type,
									data: event.target.result.split(',')[1] // base64 data without prefix
								});
								updateAttachmentsUI();
							};
							reader.readAsDataURL(blob);
						}
					}
				});
			}
		});

		// Handle all form submissions (with or without images)
		document.getElementById('input-form')?.addEventListener('submit', async function(e) {
			e.preventDefault();

			const inputField = document.getElementById('input-field');
			const text = inputField.value.trim();
			const paneTarget = this.getAttribute('data-pane-target');

			if (!paneTarget) return;

			// Input validation
			const MAX_INPUT_LENGTH = 100000; // 100KB limit for input text
			if (text.length > MAX_INPUT_LENGTH) {
				console.error('Input too long:', text.length, 'characters (max:', MAX_INPUT_LENGTH, ')');
				alert(`Input is too long (${text.length} characters). Maximum is ${MAX_INPUT_LENGTH} characters.`);
				return;
			}

			// Skip submission if input is empty (unless there are images attached)
			if (text.length === 0 && selectedImages.length === 0) {
				return;
			}

			// Check if there's pending input that needs to be cleared first
			const pendingInputBar = document.getElementById('pending-input-bar');
			const hasPendingInput = pendingInputBar && !pendingInputBar.classList.contains('hidden');

			// If there's pending input, send Ctrl+C first to clear it
			if (hasPendingInput) {
				await fetch(`/pane/${paneTarget}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: 'input=C-c&special=true'
				});
				// Wait a brief moment for the clear to take effect
				await new Promise(resolve => setTimeout(resolve, 100));
			}

			// If in NORMAL mode, switch to INSERT mode first
			if (currentVimMode === 'normal') {
				await fetch(`/pane/${paneTarget}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: 'input=i&noenter=true'
				});
				// Wait for mode switch to take effect
				await new Promise(resolve => setTimeout(resolve, 50));
			}

			let response;

			if (selectedImages.length > 0) {
				// Send with images
				response = await fetch(`/pane/${paneTarget}/send-with-images`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						text: text,
						images: selectedImages
					})
				});
			} else {
				// Send text only (URL-encoded, not multipart)
				const params = new URLSearchParams();
				params.append('input', text);
				response = await fetch(`/pane/${paneTarget}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params
				});
			}

			if (response.ok) {
				// Clear form and images
				inputField.value = '';
				inputField.style.height = 'auto';
				selectedImages = [];
				updateAttachmentsUI();
				// Hide suggestion bar (stale after user sends)
				document.getElementById('suggestion-bar')?.classList.add('hidden');
				suggestionDismissed = true;
				currentSuggestion = '';
			} else {
				const errText = await response.text().catch(() => 'Unknown error');
				console.error('Send failed:', response.status, errText);
				alert('Failed to send: ' + errText);
			}
		});

		// Allow Enter to create newlines (for iOS compatibility)
		// Only submit via Send button
		window.handleInputKeydown = function(e) {
			// Cmd/Ctrl+Enter to send (for desktop users who want keyboard shortcut)
			if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
				e.preventDefault();
				document.getElementById('input-form').requestSubmit();
			}
			// Ctrl+Shift+X to clear all attached images
			if (e.key === 'X' && e.ctrlKey && e.shiftKey) {
				e.preventDefault();
				if (selectedImages.length > 0) {
					selectedImages = [];
					updateAttachmentsUI();
				}
			}
			// Regular Enter creates newline (default behavior for textarea)
		}

		// Auto-resize textarea
		window.autoResize = function(el) {
			el.style.height = 'auto';
			el.style.height = Math.min(el.scrollHeight, 120) + 'px';
		}

		document.addEventListener('click', function(e) {
			const menu = document.getElementById('menu');
			if (!e.target.closest('#menu') && !e.target.closest('[onclick="toggleMenu()"]')) {
				menu.classList.add('hidden');
			}
		});
	</script>
	<script src="/static/app.js"></script>
}
