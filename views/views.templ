package views

import (
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/noamsto/houston/parser"
	"github.com/noamsto/houston/tmux"
)

// WindowWithStatus combines window info with its parse result
type WindowWithStatus struct {
	Window         tmux.Window
	Pane           tmux.Pane // The pane being monitored
	ParseResult    parser.Result
	Preview        []string // Last 2-3 lines for preview
	NeedsAttention bool
}

// SessionWithWindows holds a session and all its windows with status
type SessionWithWindows struct {
	Session        tmux.Session
	Windows        []WindowWithStatus
	AttentionCount int  // Number of windows needing attention
	HasWorking     bool // At least one window is working
}

// SessionsData holds data for the sessions list
type SessionsData struct {
	NeedsAttention []SessionWithWindows // Sessions with windows needing attention
	Active         []SessionWithWindows // Sessions with working windows
	Idle           []SessionWithWindows // Sessions with all idle windows
}

// Legacy: keep for backward compatibility during transition
type SessionWithStatus struct {
	Session     tmux.Session
	ParseResult parser.Result
}

// PaneData holds data for the pane view
type PaneData struct {
	Pane        tmux.Pane
	Output      string
	ParseResult parser.Result
	Windows     []tmux.Window
	Panes       []tmux.PaneInfo
}

// Helper functions
func urlEncode(s string) string {
	return url.PathEscape(s)
}

func timeAgo(t time.Time) string {
	d := time.Since(t)
	switch {
	case d < time.Minute:
		return "just now"
	case d < time.Hour:
		return fmt.Sprintf("%dm ago", int(d.Minutes()))
	case d < 24*time.Hour:
		return fmt.Sprintf("%dh ago", int(d.Hours()))
	default:
		return t.Format("Jan 2")
	}
}

func truncate(s string, n int) string {
	if len(s) <= n {
		return s
	}
	return s[:n] + "..."
}

// lastLines returns the last n non-empty lines of a string
func lastLines(s string, n int) []string {
	lines := []string{}
	for _, line := range reverseStrings(splitLines(s)) {
		trimmed := trimLine(line)
		if trimmed != "" {
			lines = append([]string{trimmed}, lines...)
			if len(lines) >= n {
				break
			}
		}
	}
	return lines
}

func splitLines(s string) []string {
	result := []string{}
	start := 0
	for i := 0; i < len(s); i++ {
		if s[i] == '\n' {
			result = append(result, s[start:i])
			start = i + 1
		}
	}
	if start < len(s) {
		result = append(result, s[start:])
	}
	return result
}

func reverseStrings(ss []string) []string {
	result := make([]string, len(ss))
	for i, s := range ss {
		result[len(ss)-1-i] = s
	}
	return result
}

func trimLine(s string) string {
	// Trim leading/trailing whitespace but keep content
	start, end := 0, len(s)
	for start < end && (s[start] == ' ' || s[start] == '\t' || s[start] == '\r') {
		start++
	}
	for end > start && (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\r') {
		end--
	}
	return s[start:end]
}

// IndexPage renders the main dashboard page with Mission Control design
templ IndexPage() {
	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
		<title>tmux mission control</title>
		<link rel="preconnect" href="https://fonts.googleapis.com"/>
		<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet"/>
		<script src="https://unpkg.com/idiomorph@0.3.0/dist/idiomorph.min.js"></script>
		<style>
			:root {
				--bg-deep: #0a0a0b;
				--bg-panel: #111113;
				--bg-elevated: #1a1a1d;
				--border: #2a2a2e;
				--text-primary: #e4e4e7;
				--text-secondary: #71717a;
				--text-dim: #52525b;
				--attention: #f97316;
				--attention-glow: rgba(249, 115, 22, 0.4);
				--error: #ef4444;
				--error-glow: rgba(239, 68, 68, 0.4);
				--working: #22c55e;
				--working-glow: rgba(34, 197, 94, 0.3);
				--idle: #3f3f46;
				--accent: #06b6d4;
				--accent-dim: rgba(6, 182, 212, 0.15);
			}
			* { box-sizing: border-box; margin: 0; padding: 0; }
			body {
				font-family: 'IBM Plex Mono', ui-monospace, monospace;
				background: var(--bg-deep);
				color: var(--text-primary);
				min-height: 100vh;
				min-height: 100dvh;
			}
			/* Scan line overlay */
			body::before {
				content: '';
				position: fixed;
				top: 0; left: 0; right: 0; bottom: 0;
				background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px);
				pointer-events: none;
				z-index: 1000;
			}
			.header {
				position: sticky;
				top: 0;
				background: var(--bg-deep);
				border-bottom: 1px solid var(--border);
				padding: 1rem;
				z-index: 100;
			}
			.header-content {
				display: flex;
				align-items: center;
				justify-content: space-between;
				max-width: 600px;
				margin: 0 auto;
			}
			.search-bar {
				padding: 0 1rem 0.75rem;
				max-width: 600px;
				margin: 0 auto;
			}
			.search-input {
				width: 100%;
				background: var(--bg-elevated);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 0.5rem 0.75rem 0.5rem 2.25rem;
				font-family: inherit;
				font-size: 14px;
				color: var(--text-primary);
				outline: none;
				background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23555566'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'/%3E%3C/svg%3E");
				background-repeat: no-repeat;
				background-position: 0.625rem center;
				background-size: 16px;
			}
			.search-input:focus {
				border-color: var(--accent);
				box-shadow: 0 0 0 2px var(--accent-dim);
			}
			.search-input::placeholder { color: var(--text-dim); }
			.logo {
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}
			.logo-icon {
				width: 24px;
				height: 24px;
				background: var(--accent);
				border-radius: 4px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 10px;
				font-weight: 600;
				color: var(--bg-deep);
			}
			.logo-text {
				font-size: 14px;
				font-weight: 500;
				color: var(--text-secondary);
			}
			.status-summary {
				display: flex;
				align-items: center;
				gap: 1rem;
				font-size: 11px;
			}
			.status-count {
				display: flex;
				align-items: center;
				gap: 0.35rem;
			}
			.status-dot {
				width: 8px;
				height: 8px;
				border-radius: 50%;
			}
			.status-dot.attention {
				background: var(--attention);
				box-shadow: 0 0 8px var(--attention-glow);
			}
			.status-dot.working {
				background: var(--working);
				box-shadow: 0 0 6px var(--working-glow);
			}
			.status-dot.idle {
				background: var(--idle);
			}
			.header-right {
				display: flex;
				align-items: center;
				gap: 0.75rem;
			}
			.notification-btn {
				background: none;
				border: none;
				font-size: 16px;
				cursor: pointer;
				padding: 0.25rem;
				opacity: 0.6;
				transition: opacity 0.15s;
			}
			.notification-btn:hover { opacity: 1; }
			.notification-btn.enabled {
				opacity: 1;
			}
			.main {
				max-width: 600px;
				margin: 0 auto;
				padding: 0.5rem;
				padding-bottom: 2rem;
			}
			.section-label {
				font-size: 10px;
				text-transform: uppercase;
				letter-spacing: 0.1em;
				color: var(--text-dim);
				padding: 1rem 0.5rem 0.5rem;
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}
			.section-label::after {
				content: '';
				flex: 1;
				height: 1px;
				background: var(--border);
			}
			.session {
				background: var(--bg-panel);
				border: 1px solid var(--border);
				border-radius: 8px;
				margin-bottom: 0.5rem;
				overflow: hidden;
			}
			.session.has-attention {
				border-color: var(--attention);
				box-shadow: 0 0 0 1px var(--attention-glow);
			}
			.session-header {
				display: flex;
				align-items: center;
				padding: 0.875rem 1rem;
				cursor: pointer;
				transition: background 0.15s;
			}
			.session-header:hover { background: var(--bg-elevated); }
			.session-indicator {
				width: 10px;
				height: 10px;
				border-radius: 50%;
				margin-right: 0.75rem;
				flex-shrink: 0;
			}
			.session-indicator.attention {
				background: var(--attention);
				box-shadow: 0 0 10px var(--attention-glow);
				animation: pulse 2s ease-in-out infinite;
			}
			.session-indicator.error {
				background: var(--error);
				box-shadow: 0 0 10px var(--error-glow);
				animation: pulse 1.5s ease-in-out infinite;
			}
			.session-indicator.working {
				background: var(--working);
				box-shadow: 0 0 8px var(--working-glow);
			}
			.session-indicator.idle { background: var(--idle); }
			@keyframes pulse {
				0%, 100% { opacity: 1; transform: scale(1); }
				50% { opacity: 0.6; transform: scale(0.9); }
			}
			.session-info { flex: 1; min-width: 0; }
			.session-name {
				font-size: 14px;
				font-weight: 500;
				color: var(--text-primary);
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}
			.session-meta {
				font-size: 11px;
				color: var(--text-secondary);
				margin-top: 2px;
			}
			.session-badge {
				font-size: 10px;
				padding: 0.25rem 0.5rem;
				border-radius: 4px;
				background: var(--attention);
				color: var(--bg-deep);
				font-weight: 600;
				margin-left: 0.5rem;
			}
			.session-chevron {
				color: var(--text-dim);
				transition: transform 0.2s;
			}
			.session.expanded .session-chevron { transform: rotate(180deg); }
			.windows {
				border-top: 1px solid var(--border);
				background: var(--bg-deep);
			}
			.windows.hidden { display: none; }
			.window {
				display: flex;
				align-items: flex-start;
				padding: 0.75rem 1rem 0.75rem 2.5rem;
				border-bottom: 1px solid var(--border);
				cursor: pointer;
				transition: background 0.15s;
				text-decoration: none;
				color: inherit;
			}
			.window:last-child { border-bottom: none; }
			.window:hover { background: var(--bg-panel); }
			.window.attention { background: rgba(249, 115, 22, 0.05); }
			.window-indicator {
				width: 6px;
				height: 6px;
				border-radius: 50%;
				margin-right: 0.75rem;
				margin-top: 0.35rem;
				flex-shrink: 0;
			}
			.window-indicator.attention {
				background: var(--attention);
				box-shadow: 0 0 6px var(--attention-glow);
				animation: pulse 2s ease-in-out infinite;
			}
			.window-indicator.error {
				background: var(--error);
				box-shadow: 0 0 6px var(--error-glow);
				animation: pulse 1.5s ease-in-out infinite;
			}
			.window-indicator.working { background: var(--working); }
			.window-indicator.idle { background: var(--idle); }
			.window-info { flex: 1; min-width: 0; }
			.window-name { font-size: 13px; color: var(--text-primary); }
			.window-status {
				font-size: 11px;
				color: var(--text-secondary);
				margin-top: 1px;
			}
			.window-status.idle { color: var(--text-dim); }
			.window-status.working { color: var(--working); }
			.window-status.attention { color: var(--attention); }
			.window-preview {
				margin-top: 0.5rem;
				padding: 0.5rem;
				background: rgba(0, 0, 0, 0.3);
				border-radius: 4px;
				font-size: 11px;
				line-height: 1.4;
				max-height: 4.5em;
				overflow: hidden;
			}
			.preview-line {
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				color: var(--text-secondary);
			}
			.window-actions {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 0.25rem;
				flex-shrink: 0;
			}
			.window-view-btn {
				color: var(--text-secondary);
				text-decoration: none;
				font-size: 10px;
				text-transform: uppercase;
				letter-spacing: 0.5px;
				padding: 0.2rem 0.5rem;
				border-radius: 3px;
				transition: all 0.15s;
				background: rgba(255, 255, 255, 0.08);
				border: 1px solid rgba(255, 255, 255, 0.1);
			}
			.window-view-btn:hover, .window-view-btn:active {
				color: #60a5fa;
				background: rgba(59, 130, 246, 0.2);
				border-color: rgba(59, 130, 246, 0.3);
			}
			.window-arrow {
				color: var(--text-dim);
				font-size: 12px;
			}
			.empty-state {
				text-align: center;
				padding: 4rem 2rem;
				color: var(--text-secondary);
			}
			.empty-icon { font-size: 48px; margin-bottom: 1rem; opacity: 0.5; }
			/* Action bar */
			.action-backdrop {
				position: fixed;
				inset: 0;
				background: rgba(0, 0, 0, 0.5);
				opacity: 0;
				visibility: hidden;
				transition: opacity 0.3s, visibility 0.3s;
				z-index: 190;
			}
			.action-backdrop.visible {
				opacity: 1;
				visibility: visible;
			}
			.action-bar {
				position: fixed;
				bottom: 0;
				left: 0;
				right: 0;
				background: var(--bg-panel);
				border-top: 1px solid var(--border);
				padding: 0.5rem;
				padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));
				transform: translateY(100%);
				transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
				z-index: 200;
			}
			.action-bar.visible { transform: translateY(0); }
			.action-bar-content {
				max-width: 100%;
			}
			.action-target {
				font-size: 11px;
				color: var(--text-secondary);
				margin-bottom: 0.5rem;
				display: flex;
				align-items: center;
				justify-content: space-between;
			}
			.action-close {
				background: none;
				border: none;
				color: var(--text-dim);
				cursor: pointer;
				padding: 0.25rem;
				font-size: 14px;
			}
			.action-input-row {
				display: flex;
				gap: 0.375rem;
			}
			.action-input {
				flex: 1;
				min-width: 0;
				background: var(--bg-deep);
				border: 1px solid var(--border);
				border-radius: 6px;
				padding: 0.5rem 0.75rem;
				font-family: inherit;
				font-size: 14px;
				color: var(--text-primary);
				outline: none;
			}
			.action-input:focus {
				border-color: var(--accent);
				box-shadow: 0 0 0 2px var(--accent-dim);
			}
			.action-input::placeholder { color: var(--text-dim); }
			.action-btn {
				background: var(--accent);
				border: none;
				border-radius: 6px;
				padding: 0.5rem 0.75rem;
				font-family: inherit;
				font-size: 13px;
				font-weight: 500;
				color: var(--bg-deep);
				cursor: pointer;
				transition: opacity 0.15s;
				flex-shrink: 0;
				white-space: nowrap;
			}
			.action-btn:active { opacity: 0.8; }
			.action-btn.stop {
				background: var(--error);
				color: white;
				padding: 0.5rem;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.action-btn.view {
				background: #3b82f6;
				color: white;
			}
			.action-context {
				margin-bottom: 0.5rem;
				padding: 0.5rem;
				background: var(--bg-deep);
				border-radius: 6px;
				border-left: 3px solid var(--idle);
			}
			.action-context.attention { border-left-color: var(--attention); }
			.action-context.working { border-left-color: var(--working); }
			.action-status {
				font-size: 12px;
				font-weight: 500;
				margin-bottom: 0.5rem;
			}
			.action-status.attention { color: var(--attention); }
			.action-status.working { color: var(--working); }
			.action-preview {
				font-size: 11px;
				color: var(--text-secondary);
				line-height: 1.4;
				max-height: 12em;
				overflow-y: auto;
			}
			.action-preview-line {
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}
			.action-choices {
				display: flex;
				gap: 0.5rem;
				margin-bottom: 0.75rem;
			}
			.action-choices.hidden { display: none; }
			.choice-btn {
				flex: 1;
				padding: 0.625rem 0.5rem;
				background: var(--bg-elevated);
				border: 1px solid var(--border);
				border-radius: 6px;
				color: var(--text-primary);
				font-family: inherit;
				font-size: 12px;
				cursor: pointer;
				transition: all 0.15s;
				text-align: center;
				line-height: 1.3;
			}
			.choice-btn:hover {
				background: var(--accent-dim);
				border-color: var(--accent);
			}
			.choice-btn:active { transform: scale(0.98); }
			.choice-num {
				display: block;
				font-size: 14px;
				font-weight: 600;
				color: var(--accent);
				margin-bottom: 2px;
			}
		</style>
	</head>
	<body>
		<header class="header">
			<div class="header-content">
				<div class="logo">
					<div class="logo-icon">MC</div>
					<span class="logo-text">mission control</span>
				</div>
				<div class="header-right">
					<div class="status-summary" id="status-summary"></div>
					<button class="notification-btn" id="notificationBtn" onclick="toggleNotifications()" title="Toggle notifications">
						<span class="notification-icon">ðŸ”•</span>
					</button>
				</div>
			</div>
			<div class="search-bar">
				<input type="text" class="search-input" id="searchInput" placeholder="Filter sessions..." oninput="filterSessions(this.value)"/>
			</div>
		</header>
		<main class="main">
			<div id="sessions">
				<div class="empty-state">
					<p>Loading...</p>
				</div>
			</div>
		</main>
		<!-- Action bar backdrop -->
		<div class="action-backdrop" id="actionBackdrop" onclick="closeActionBar()"></div>
		<!-- Action bar -->
		<div class="action-bar" id="actionBar">
			<div class="action-bar-content">
				<div class="action-target">
					<span id="actionTarget"></span>
					<button class="action-close" onclick="closeActionBar()">âœ•</button>
				</div>
				<div class="action-context" id="actionContext">
					<div class="action-status" id="actionStatus"></div>
					<div class="action-preview" id="actionPreview"></div>
				</div>
				<div class="action-choices hidden" id="actionChoices"></div>
				<div class="action-input-row">
					<input type="text" class="action-input" placeholder="Send input..." id="actionInput"/>
					<button class="action-btn stop" onclick="sendStop()" title="Stop (Ctrl+C)">
						<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
						</svg>
					</button>
					<button class="action-btn view" onclick="viewPane()">View</button>
					<button class="action-btn" onclick="sendInput()">Send</button>
				</div>
			</div>
		</div>
		<script src="/static/app.js"></script>
		<script>
			// Track expanded sessions
			const expandedSessions = new Set();
			let selectedTarget = null;
			let currentFilter = '';

			function filterSessions(query) {
				currentFilter = query.toLowerCase().trim();
				const sessions = document.querySelectorAll('#sessions .session');

				sessions.forEach(session => {
					const sessionName = session.dataset.session?.toLowerCase() || '';
					const windows = session.querySelectorAll('.window');
					let hasMatch = false;

					windows.forEach(win => {
						const windowName = (win.dataset.name || '').toLowerCase();
						const matches = !currentFilter ||
							sessionName.includes(currentFilter) ||
							windowName.includes(currentFilter);

						win.style.display = matches ? '' : 'none';
						if (matches) hasMatch = true;
					});

					// Show session if name matches or any window matches
					const sessionMatches = !currentFilter || sessionName.includes(currentFilter) || hasMatch;
					session.style.display = sessionMatches ? '' : 'none';

					// Auto-expand if filtering and has matches
					if (currentFilter && hasMatch) {
						session.classList.add('expanded');
						session.querySelector('.windows')?.classList.remove('hidden');
					}
				});
			}

			function toggleSession(header) {
				const session = header.closest('.session');
				const windows = session.querySelector('.windows');
				const sessionName = session.dataset.session;

				session.classList.toggle('expanded');
				windows.classList.toggle('hidden');

				if (session.classList.contains('expanded')) {
					expandedSessions.add(sessionName);
				} else {
					expandedSessions.delete(sessionName);
				}
			}

			function restoreExpandedState() {
				document.querySelectorAll('.session').forEach(session => {
					const name = session.dataset.session;
					if (expandedSessions.has(name)) {
						session.classList.add('expanded');
						session.querySelector('.windows')?.classList.remove('hidden');
					}
				});
			}

			// Update status summary counts in header
			function updateStatusSummary() {
				const container = document.getElementById('sessions');
				const attention = container.querySelectorAll('.window-indicator.attention').length;
				const error = container.querySelectorAll('.window-indicator.error').length;
				const working = container.querySelectorAll('.window-indicator.working').length;
				const idle = container.querySelectorAll('.window-indicator.idle').length;

				const summary = document.getElementById('status-summary');
				let html = '';
				if (attention + error > 0) {
					html += `<div class="status-count"><div class="status-dot attention"></div><span>${attention + error}</span></div>`;
				}
				if (working > 0) {
					html += `<div class="status-count"><div class="status-dot working"></div><span>${working}</span></div>`;
				}
				if (idle > 0) {
					html += `<div class="status-count"><div class="status-dot idle"></div><span>${idle}</span></div>`;
				}
				summary.innerHTML = html;
			}

			// Action bar functions
			function selectWindow(el) {
				const session = el.dataset.session;
				const windowIdx = parseInt(el.dataset.window);
				const paneIdx = parseInt(el.dataset.pane || '0');
				const windowName = el.dataset.name;
				const status = el.dataset.status;
				const indicator = el.dataset.indicator;
				const preview = el.dataset.preview;
				const question = el.dataset.question;
				const choices = el.dataset.choices;

				selectedTarget = { session, window: windowIdx, pane: paneIdx };
				document.getElementById('actionTarget').textContent = `${session}:${windowIdx} ${windowName}`;

				// Update context area
				const context = document.getElementById('actionContext');
				const statusEl = document.getElementById('actionStatus');
				const previewEl = document.getElementById('actionPreview');

				context.className = 'action-context ' + indicator;
				statusEl.className = 'action-status ' + indicator;
				statusEl.textContent = status;

				// Show choices if available, then preview (don't duplicate question - it's in status)
				let html = '';
				if (choices) {
					const choiceList = choices.split('|');
					choiceList.forEach((choice, i) => {
						html += `<div class="action-preview-line" style="padding-left: 0.5rem;">${i + 1}. ${escapeHtml(choice)}</div>`;
					});
				}
				// Show preview, filtering out lines that match the question/status
				if (preview) {
					if (html) html += '<div style="margin-top: 0.5rem; border-top: 1px solid var(--border); padding-top: 0.5rem;"></div>';
					const previewLines = preview.split('\n').filter(line => {
						// Skip lines that are the same as status/question to avoid duplication
						const trimmed = line.trim();
						if (question && trimmed === question.trim()) return false;
						if (status && trimmed === status.trim()) return false;
						return true;
					});
					html += previewLines.map(line =>
						`<div class="action-preview-line">${escapeHtml(line)}</div>`
					).join('');
				}
				if (!html) {
					html = '<div class="action-preview-line">No output</div>';
				}
				previewEl.innerHTML = html;

				// Show choice buttons if choices available
				const choicesEl = document.getElementById('actionChoices');
				if (choices) {
					const choiceList = choices.split('|');
					let btnHtml = '';
					choiceList.forEach((choice, i) => {
						const shortChoice = choice.length > 25 ? choice.substring(0, 22) + '...' : choice;
						btnHtml += `<button class="choice-btn" onclick="sendChoice(${i + 1})">
							<span class="choice-num">${i + 1}</span>
							${escapeHtml(shortChoice)}
						</button>`;
					});
					choicesEl.innerHTML = btnHtml;
					choicesEl.classList.remove('hidden');
				} else {
					choicesEl.classList.add('hidden');
				}

				document.getElementById('actionBackdrop').classList.add('visible');
				document.getElementById('actionBar').classList.add('visible');
				document.getElementById('actionInput').focus();
			}

			function sendChoice(num) {
				if (!selectedTarget) return;
				fetch(`/pane/${encodeURIComponent(selectedTarget.session)}:${selectedTarget.window}.${selectedTarget.pane}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: `input=${num}&noenter=true`
				});
				closeActionBar();
			}

			function escapeHtml(text) {
				const div = document.createElement('div');
				div.textContent = text;
				return div.innerHTML;
			}

			function closeActionBar() {
				document.getElementById('actionBackdrop').classList.remove('visible');
				document.getElementById('actionBar').classList.remove('visible');
				selectedTarget = null;
			}

			function refreshActionBar() {
				if (!selectedTarget) return;
				// Find the updated window element
				const windowEl = document.querySelector(
					`.window[data-session="${selectedTarget.session}"][data-window="${selectedTarget.window}"]`
				);
				if (windowEl) {
					// Re-trigger selectWindow to refresh the action bar content
					selectWindow(windowEl);
				}
			}

			function sendInput() {
				if (!selectedTarget) return;
				const input = document.getElementById('actionInput');
				const value = input.value;
				if (!value) return;

				fetch(`/pane/${encodeURIComponent(selectedTarget.session)}:${selectedTarget.window}.${selectedTarget.pane}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: `input=${encodeURIComponent(value)}`
				});
				input.value = '';
			}

			function sendStop() {
				if (!selectedTarget) return;
				fetch(`/pane/${encodeURIComponent(selectedTarget.session)}:${selectedTarget.window}.${selectedTarget.pane}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: 'input=C-c&special=true'
				});
			}

			function viewPane() {
				if (!selectedTarget) return;
				window.location.href = `/pane/${encodeURIComponent(selectedTarget.session)}:${selectedTarget.window}.${selectedTarget.pane}`;
			}

			// Close action bar on escape
			document.addEventListener('keydown', (e) => {
				if (e.key === 'Escape') closeActionBar();
				if (e.key === 'Enter' && document.activeElement.id === 'actionInput') {
					e.preventDefault();
					sendInput();
				}
			});

			// Handle SSE manually for flicker-free updates
			function connectSSE() {
				const evtSource = new EventSource('/sessions?stream=1');
				const container = document.getElementById('sessions');

				evtSource.onmessage = function(e) {
					const temp = document.createElement('div');
					temp.innerHTML = e.data;

					temp.querySelectorAll('.session').forEach(session => {
						const name = session.dataset.session;
						// Auto-expand sessions that need attention, or were manually expanded
						if (expandedSessions.has(name) || session.classList.contains('has-attention')) {
							session.classList.add('expanded');
							session.querySelector('.windows')?.classList.remove('hidden');
							expandedSessions.add(name); // Track auto-expanded too
						}
					});

					Idiomorph.morph(container, temp.innerHTML, { morphStyle: 'innerHTML' });
					updateStatusSummary();
					// Re-apply filter if active
					if (currentFilter) {
						filterSessions(currentFilter);
					}
					// Refresh action bar if open
					refreshActionBar();
				};

				evtSource.onerror = function() {
					console.log('SSE connection lost, reconnecting...');
					evtSource.close();
					setTimeout(connectSSE, 3000);
				};
			}

			connectSSE();

			// Notification support
			let notificationsEnabled = false;
			let notifiedPanes = new Set();

			async function toggleNotifications() {
				const btn = document.getElementById('notificationBtn');

				if (!notificationsEnabled) {
					// Request permission
					if (!('Notification' in window)) {
						alert('Notifications not supported in this browser');
						return;
					}

					const permission = await Notification.requestPermission();
					if (permission === 'granted') {
						// Register service worker
						if ('serviceWorker' in navigator) {
							try {
								await navigator.serviceWorker.register('/static/sw.js');
							} catch (e) {
								console.log('Service worker registration failed:', e);
							}
						}
						notificationsEnabled = true;
						btn.classList.add('enabled');
						btn.querySelector('.notification-icon').textContent = 'ðŸ””';
						btn.title = 'Notifications enabled';
					}
				} else {
					notificationsEnabled = false;
					btn.classList.remove('enabled');
					btn.querySelector('.notification-icon').textContent = 'ðŸ”•';
					btn.title = 'Notifications disabled';
					notifiedPanes.clear();
				}
			}

			function checkAndNotify() {
				if (!notificationsEnabled) return;

				const attentionWindows = document.querySelectorAll('.window-indicator.attention');
				attentionWindows.forEach(indicator => {
					const win = indicator.closest('.window');
					if (!win) return;

					const paneKey = `${win.dataset.session}:${win.dataset.window}.${win.dataset.pane}`;
					if (notifiedPanes.has(paneKey)) return;

					notifiedPanes.add(paneKey);

					const title = `${win.dataset.session}:${win.dataset.window}`;
					const body = win.dataset.status || 'Needs attention';

					new Notification(title, {
						body: body,
						icon: '/static/icon.png',
						tag: paneKey,
						data: { url: `/pane/${paneKey}` }
					});
				});

				// Clean up notified panes that no longer need attention
				const currentAttention = new Set();
				attentionWindows.forEach(indicator => {
					const win = indicator.closest('.window');
					if (win) {
						currentAttention.add(`${win.dataset.session}:${win.dataset.window}.${win.dataset.pane}`);
					}
				});
				notifiedPanes = new Set([...notifiedPanes].filter(p => currentAttention.has(p)));
			}

			// Check for attention-needing panes after SSE updates
			const originalMorph = Idiomorph.morph;
			Idiomorph.morph = function(...args) {
				const result = originalMorph.apply(this, args);
				setTimeout(checkAndNotify, 100);
				return result;
			};
		</script>
	</body>
	</html>
}

// Sessions renders the sessions list with window-level detail
templ Sessions(data SessionsData) {
	// Needs Attention section
	if len(data.NeedsAttention) > 0 {
		<div class="section-label">Needs attention</div>
		for _, sess := range data.NeedsAttention {
			@sessionCardV2(sess, true)
		}
	}
	// Active section
	if len(data.Active) > 0 {
		<div class="section-label">Active</div>
		for _, sess := range data.Active {
			@sessionCardV2(sess, false)
		}
	}
	// Idle section
	if len(data.Idle) > 0 {
		<div class="section-label">Idle</div>
		for _, sess := range data.Idle {
			@sessionCardV2(sess, false)
		}
	}
	// Empty state
	if len(data.NeedsAttention) == 0 && len(data.Active) == 0 && len(data.Idle) == 0 {
		<div class="empty-state">
			<div class="empty-icon">â—¯</div>
			<p>No tmux sessions</p>
		</div>
	}
}

// sessionCardV2 renders a session with its windows
templ sessionCardV2(sess SessionWithWindows, expanded bool) {
	<div class={ "session", templ.KV("has-attention", sess.AttentionCount > 0), templ.KV("expanded", expanded) } data-session={ sess.Session.Name }>
		<div class="session-header" onclick="toggleSession(this)">
			<div class={ "session-indicator", getSessionIndicator(sess) }></div>
			<div class="session-info">
				<div class="session-name">{ sess.Session.Name }</div>
				<div class="session-meta">{ fmt.Sprintf("%d windows", len(sess.Windows)) }</div>
			</div>
			if sess.AttentionCount > 0 {
				<span class="session-badge">{ fmt.Sprintf("%d", sess.AttentionCount) }</span>
			}
			<svg class="session-chevron" width="20" height="20" viewBox="0 0 20 20" fill="none">
				<path d="M5 7.5L10 12.5L15 7.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path>
			</svg>
		</div>
		<div class={ "windows", templ.KV("hidden", !expanded) }>
			for _, win := range sess.Windows {
				@windowCard(sess.Session.Name, win)
			}
		</div>
	</div>
}

// escapeJS escapes a string for safe use in JavaScript
func escapeJS(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "'", "\\'")
	return s
}

// windowCard renders a single window within a session
templ windowCard(sessionName string, win WindowWithStatus) {
	<div
		data-session={ sessionName }
		data-window={ fmt.Sprintf("%d", win.Window.Index) }
		data-pane={ fmt.Sprintf("%d", win.Pane.Index) }
		data-name={ win.Window.Name }
		data-status={ getWindowStatusText(win) }
		data-indicator={ getWindowIndicator(win) }
		data-preview={ strings.Join(win.Preview, "\n") }
		data-question={ win.ParseResult.Question }
		data-choices={ strings.Join(win.ParseResult.Choices, "|") }
		onclick="selectWindow(this)"
		class={ "window", templ.KV("attention", win.NeedsAttention) }
	>
		<div class={ "window-indicator", getWindowIndicator(win) }></div>
		<div class="window-info">
			<div class="window-name">{ fmt.Sprintf("%d: %s", win.Window.Index, win.Window.Name) }</div>
			<div class={ "window-status", getWindowIndicator(win) }>
				{ getWindowStatusText(win) }
			</div>
			if len(win.Preview) > 0 {
				<div class="window-preview">
					for _, line := range win.Preview {
						<div class="preview-line">{ line }</div>
					}
				</div>
			}
		</div>
		<div class="window-actions">
			<a href={ templ.SafeURL(fmt.Sprintf("/pane/%s:%d.%d", sessionName, win.Window.Index, win.Pane.Index)) }
				class="window-view-btn"
				onclick="event.stopPropagation()"
				title="Open pane view">view</a>
			<span class="window-arrow">â†’</span>
		</div>
	</div>
}

// Helper functions for template
func getSessionIndicator(sess SessionWithWindows) string {
	if sess.AttentionCount > 0 {
		return "attention"
	}
	if sess.HasWorking {
		return "working"
	}
	return "idle"
}

func getWindowIndicator(win WindowWithStatus) string {
	if win.NeedsAttention {
		return "attention"
	}
	if win.ParseResult.Type == parser.TypeWorking {
		return "working"
	}
	return "idle"
}

func getWindowStatusText(win WindowWithStatus) string {
	switch win.ParseResult.Type {
	case parser.TypeError:
		return "Error"
	case parser.TypeChoice:
		return "Waiting for choice..."
	case parser.TypeQuestion:
		if win.ParseResult.Question != "" {
			q := win.ParseResult.Question
			if len(q) > 40 {
				q = q[:37] + "..."
			}
			return q
		}
		return "Waiting for input..."
	case parser.TypeWorking:
		if win.ParseResult.Activity != "" {
			return win.ParseResult.Activity + "..."
		}
		return "Working..."
	default:
		return "Idle"
	}
}

// PanePage renders the pane view
templ PanePage(data PaneData) {
	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
		<title>{ data.Pane.Session } - houston</title>
		<script src="https://unpkg.com/htmx.org@1.9.10"></script>
		<script src="https://unpkg.com/htmx.org@1.9.10/dist/ext/sse.js"></script>
		<style>
			:root {
				--bg-deep: #0a0a0f;
				--bg-panel: #12121a;
				--bg-elevated: #1a1a24;
				--border: #2a2a3a;
				--text-primary: #e8e8f0;
				--text-secondary: #8888a0;
				--text-dim: #555566;
				--accent: #00d4aa;
				--accent-dim: rgba(0, 212, 170, 0.15);
				--attention: #f97316;
				--error: #ef4444;
				--working: #3b82f6;
				--idle: #6b7280;
			}
			* { box-sizing: border-box; margin: 0; padding: 0; }
			body {
				font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', system-ui, sans-serif;
				background: var(--bg-deep);
				color: var(--text-primary);
				min-height: 100vh;
				min-height: 100dvh;
			}
			.terminal {
				font-family: 'SF Mono', ui-monospace, monospace;
				font-size: 12px;
				line-height: 1.5;
				-webkit-user-select: text;
				user-select: text;
				cursor: text;
			}
			.diff-add { background-color: rgba(34, 197, 94, 0.25); }
			.diff-del { background-color: rgba(239, 68, 68, 0.25); }
			.diff-hunk { background-color: rgba(59, 130, 246, 0.25); }
			.header {
				background: var(--bg-panel);
				border-bottom: 1px solid var(--border);
				padding: 0.75rem 1rem;
				display: flex;
				align-items: center;
				gap: 0.75rem;
			}
			.back-btn {
				background: none;
				border: none;
				color: var(--text-secondary);
				padding: 0.5rem;
				margin: -0.5rem;
				cursor: pointer;
				border-radius: 6px;
			}
			.back-btn:hover { background: var(--bg-elevated); color: var(--text-primary); }
			.header-title {
				flex: 1;
				font-weight: 500;
				font-size: 15px;
				color: var(--text-primary);
			}
			.header-target {
				font-size: 12px;
				color: var(--text-secondary);
				font-family: 'SF Mono', ui-monospace, monospace;
			}
			.menu-btn {
				background: none;
				border: none;
				color: var(--text-secondary);
				padding: 0.5rem;
				cursor: pointer;
				border-radius: 6px;
			}
			.menu-btn:hover { background: var(--bg-elevated); color: var(--text-primary); }
			.menu {
				position: absolute;
				right: 0;
				top: 100%;
				margin-top: 0.5rem;
				background: var(--bg-elevated);
				border: 1px solid var(--border);
				border-radius: 8px;
				min-width: 160px;
				z-index: 100;
				box-shadow: 0 4px 12px rgba(0,0,0,0.4);
			}
			.menu.hidden { display: none; }
			.menu button {
				width: 100%;
				text-align: left;
				padding: 0.625rem 1rem;
				background: none;
				border: none;
				color: var(--text-primary);
				font-size: 13px;
				cursor: pointer;
			}
			.menu button:hover { background: var(--bg-panel); }
			.selector {
				display: flex;
				gap: 0.5rem;
				padding: 0.5rem 0.75rem;
				background: var(--bg-panel);
				border-bottom: 1px solid var(--border);
				overflow-x: auto;
				-webkit-overflow-scrolling: touch;
			}
			.selector::-webkit-scrollbar { display: none; }
			.selector-item {
				padding: 0.375rem 0.75rem;
				border-radius: 6px;
				font-size: 12px;
				white-space: nowrap;
				text-decoration: none;
				background: var(--bg-elevated);
				color: var(--text-secondary);
				border: 1px solid transparent;
				transition: all 0.15s;
			}
			.selector-item:hover { color: var(--text-primary); border-color: var(--border); }
			.selector-item.active {
				background: var(--accent-dim);
				color: var(--accent);
				border-color: var(--accent);
			}
			.selector-item.pane-active {
				background: rgba(59, 130, 246, 0.15);
				color: var(--working);
				border-color: var(--working);
			}
			.selector-sep {
				color: var(--text-dim);
				padding: 0 0.25rem;
				align-self: center;
			}
			.output-container {
				flex: 1;
				overflow-y: auto;
				background: var(--bg-deep);
				-webkit-overflow-scrolling: touch;
			}
			.output {
				padding: 1rem;
				color: var(--text-primary);
				white-space: pre;
				overflow-x: auto;
				min-width: 100%;
			}
			.choices-bar {
				display: flex;
				gap: 0.5rem;
				padding: 0.75rem;
				background: var(--bg-panel);
				border-top: 1px solid var(--border);
			}
			.choice-btn {
				flex: 1;
				padding: 0.625rem 0.5rem;
				background: var(--bg-elevated);
				border: 1px solid var(--border);
				border-radius: 6px;
				color: var(--text-primary);
				font-size: 12px;
				cursor: pointer;
				text-align: center;
				line-height: 1.3;
				transition: all 0.15s;
			}
			.choice-btn:hover {
				background: var(--accent-dim);
				border-color: var(--accent);
			}
			.choice-num {
				display: block;
				font-size: 14px;
				font-weight: 600;
				color: var(--accent);
				margin-bottom: 2px;
			}
			.choice-text {
				display: block;
				font-size: 11px;
				color: var(--text-secondary);
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}
			.input-bar {
				display: flex;
				gap: 0.5rem;
				padding: 0.75rem;
				padding-bottom: calc(0.75rem + env(safe-area-inset-bottom));
				background: var(--bg-panel);
				border-top: 1px solid var(--border);
				align-items: center;
			}
			.mode-badge {
				font-size: 10px;
				font-weight: 600;
				padding: 0.25rem 0.5rem;
				border-radius: 4px;
				font-family: 'SF Mono', ui-monospace, monospace;
			}
			.mode-badge.insert { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
			.mode-badge.normal { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
			.input-field {
				flex: 1;
				background: var(--bg-deep);
				border: 1px solid var(--border);
				border-radius: 6px;
				padding: 0.625rem 0.875rem;
				font-family: inherit;
				font-size: 14px;
				color: var(--text-primary);
				resize: none;
				outline: none;
			}
			.input-field:focus {
				border-color: var(--accent);
				box-shadow: 0 0 0 2px var(--accent-dim);
			}
			.input-field::placeholder { color: var(--text-dim); }
			.action-btn {
				padding: 0.5rem;
				border: none;
				border-radius: 6px;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.action-btn.stop { background: var(--error); color: white; }
			.action-btn.stop:hover { opacity: 0.9; }
			.action-btn.send { background: var(--accent); color: var(--bg-deep); }
			.action-btn.send:hover { opacity: 0.9; }
		</style>
	</head>
	<body>
		<div style="display: flex; flex-direction: column; height: 100vh; height: 100dvh; max-width: 32rem; margin: 0 auto;">
			<!-- Header -->
			<header class="header">
				<a href="/" class="back-btn">
					<svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
					</svg>
				</a>
				<div class="header-title">{ data.Pane.Session }</div>
				<div class="header-target">{ fmt.Sprintf(":%d.%d", data.Pane.Window, data.Pane.Index) }</div>
				<div style="position: relative;">
					<button class="menu-btn" onclick="toggleMenu()">
						<svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"></path>
						</svg>
					</button>
					<div id="menu" class="menu hidden">
						<button
							hx-post={ "/pane/" + data.Pane.URLTarget() + "/send" }
							hx-vals='{"input": "C-c", "special": "true"}'
						>Send Ctrl+C</button>
						<button onclick="scrollToTop()">Scroll to top</button>
						<button
							hx-get={ "/pane/" + data.Pane.URLTarget() }
							hx-target="#output"
							hx-swap="innerHTML"
						>Refresh</button>
					</div>
				</div>
			</header>
			<!-- Window/Pane selector -->
			if len(data.Windows) > 1 || len(data.Panes) > 1 {
				<div class="selector">
					if len(data.Windows) > 1 {
						for _, w := range data.Windows {
							<a
								href={ templ.SafeURL("/pane/" + urlEncode(data.Pane.Session) + ":" + fmt.Sprintf("%d", w.Index)) }
								class={ "selector-item", templ.KV("active", w.Index == data.Pane.Window) }
							>
								{ fmt.Sprintf("%d: %s", w.Index, w.Name) }
							</a>
						}
					}
					if len(data.Panes) > 1 {
						<span class="selector-sep">|</span>
						for _, p := range data.Panes {
							<a
								href={ templ.SafeURL("/pane/" + urlEncode(data.Pane.Session) + ":" + fmt.Sprintf("%d.%d", data.Pane.Window, p.Index)) }
								class={ "selector-item", templ.KV("pane-active", p.Index == data.Pane.Index) }
							>
								{ fmt.Sprintf("P%d", p.Index) }
								<span style="font-size: 10px; opacity: 0.7; margin-left: 4px;">{ p.Command }</span>
							</a>
						}
					}
				</div>
			}
			<!-- Output area -->
			<div
				id="output-container"
				class="output-container"
				hx-ext="sse"
				sse-connect={ "/pane/" + data.Pane.URLTarget() + "?stream=1" }
				sse-swap="message"
				hx-target="#output"
				hx-swap="none"
			>
				<pre id="output" class="terminal output">{ data.Output }</pre>
			</div>
			if len(data.ParseResult.Choices) > 0 {
				<!-- Quick choice buttons -->
				<div class="choices-bar">
					for i, choice := range data.ParseResult.Choices {
						if i < 4 {
							<button
								class="choice-btn"
								hx-post={ "/pane/" + data.Pane.URLTarget() + "/send" }
								hx-vals={ fmt.Sprintf(`{"input": "%d", "noenter": "true"}`, i+1) }
								hx-swap="none"
								hx-on::after-request="setTimeout(() => { const c = document.getElementById('output-container'); c.scrollTop = c.scrollHeight; }, 100)"
							>
								<span class="choice-num">{ fmt.Sprintf("%d", i+1) }</span>
								<span class="choice-text">{ truncate(choice, 20) }</span>
							</button>
						}
					}
				</div>
			}
			<!-- Input bar -->
			<form
				id="input-form"
				class="input-bar"
				hx-post={ "/pane/" + data.Pane.URLTarget() + "/send" }
				hx-swap="none"
				hx-on::after-request="this.reset(); document.getElementById('input-field').style.height = 'auto';"
			>
				if data.ParseResult.Mode.String() == "insert" {
					<span id="mode-indicator" class="mode-badge insert">INS</span>
				} else {
					<span id="mode-indicator" class="mode-badge normal">NOR</span>
				}
				<textarea
					id="input-field"
					name="input"
					class="input-field"
					placeholder="Send input..."
					autocomplete="off"
					rows="1"
					onkeydown="handleInputKeydown(event)"
					oninput="autoResize(this)"
				></textarea>
				<!-- Stop button -->
				<button
					type="button"
					class="action-btn stop"
					hx-post={ "/pane/" + data.Pane.URLTarget() + "/send" }
					hx-vals='{"input": "C-c", "special": "true"}'
					hx-swap="none"
					title="Stop (Ctrl+C)"
				>
					<svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
					</svg>
				</button>
				<!-- Send button -->
				<button type="submit" class="action-btn send" title="Send">
					<svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"></path>
					</svg>
				</button>
			</form>
		</div>
		@paneScripts()
	</body>
	</html>
}

// paneScripts contains the JavaScript for the pane page
templ paneScripts() {
	<script type="module">
		import { AnsiUp } from 'https://cdn.jsdelivr.net/npm/ansi_up@6/ansi_up.js';

		const ansiUp = new AnsiUp();
		ansiUp.escapeHtml = true;  // Ensure HTML is escaped (v6 uses camelCase)

		// Strip ANSI background colors from ansi_up output
		// Only target rgb() values (ansi_up uses rgb, not rgba) to avoid stripping CSS code in terminal content
		function fixBackgrounds(html) {
			html = html.replace(/background-color:\s*rgb\([^)]+\);?/gi, '');
			return html;
		}

		// Add subtle backgrounds for diff lines
		// Claude Code format: "703 +  code" or "703 -  code" (line number, space, +/-, space, code)
		function enhanceDiffs(html) {
			const lines = html.split('\n');
			return lines.map(line => {
				const stripped = line.replace(/<[^>]*>/g, ''); // Strip HTML tags to check content
				// Match Claude Code diff format: line_number +/- code
				const match = stripped.match(/^\s*\d+\s+([-+])\s/);
				if (match) {
					if (match[1] === '+') {
						return '<span class="diff-add">' + line + '</span>';
					} else {
						return '<span class="diff-del">' + line + '</span>';
					}
				}
				// Also match standard diff format (starts with +/- directly)
				if (stripped.startsWith('+') && !stripped.startsWith('+++')) {
					return '<span class="diff-add">' + line + '</span>';
				} else if (stripped.startsWith('-') && !stripped.startsWith('---')) {
					return '<span class="diff-del">' + line + '</span>';
				} else if (stripped.startsWith('@@')) {
					return '<span class="diff-hunk">' + line + '</span>';
				}
				return line;
			}).join('\n');
		}

		function processOutput(text) {
			try {
				// Normalize line endings and remove carriage returns
				text = text.replace(/\r\n/g, '\n').replace(/\r/g, '');
				let html = ansiUp.ansi_to_html(text);
				html = fixBackgrounds(html);
				html = enhanceDiffs(html);
				return html;
			} catch (err) {
				console.error('ansi_up error:', err);
				// Fallback: escape HTML and preserve newlines
				return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
			}
		}

		document.addEventListener('DOMContentLoaded', function() {
			const container = document.getElementById('output-container');
			if (container) {
				container.scrollTop = container.scrollHeight;
			}
			const output = document.getElementById('output');
			if (output) {
				output.innerHTML = processOutput(output.textContent);
			}
		});

		// Handle SSE messages manually to prevent htmx from setting innerHTML directly
		// This prevents terminal content with HTML-like text from being rendered as actual HTML
		document.body.addEventListener('htmx:sseMessage', function(e) {
			console.debug('SSE message received', e.detail.data?.length || 0, 'bytes');
			const output = document.getElementById('output');
			if (!output) return;

			const container = document.getElementById('output-container');
			// Check if user is at the bottom before updating (with 50px threshold)
			const wasAtBottom = container &&
				(container.scrollTop + container.clientHeight >= container.scrollHeight - 50);

			// Get the raw text from SSE (already safe as plain text)
			let text = e.detail.data;

			// Extract mode from special first line if present
			const modeMatch = text.match(/^__MODE__:(\w*)\n/);
			if (modeMatch) {
				const mode = modeMatch[1];
				text = text.substring(modeMatch[0].length);
				updateModeIndicatorDirect(mode);
			}

			// Process with ansi_up (which has escapeHtml enabled)
			output.innerHTML = processOutput(text);

			// Only auto-scroll if user was already at the bottom
			if (wasAtBottom && container) {
				container.scrollTop = container.scrollHeight;
			}
		});

		// Log SSE connection events
		document.body.addEventListener('htmx:sseOpen', function(e) {
			console.log('SSE connected');
		});

		document.body.addEventListener('htmx:sseError', function(e) {
			console.warn('SSE error', e.detail);
		});

		// Update mode indicator based on mode string from server
		function updateModeIndicatorDirect(mode) {
			const modeEl = document.getElementById('mode-indicator');
			if (!modeEl) return;

			if (mode === 'insert') {
				modeEl.textContent = 'INS';
				modeEl.className = 'text-xs px-2 py-1 bg-green-600 text-white rounded font-medium shadow-sm';
			} else {
				modeEl.textContent = 'NOR';
				modeEl.className = 'text-xs px-2 py-1 bg-blue-600 text-white rounded font-medium shadow-sm';
			}
		}

		// Fallback: Update mode indicator by parsing text (for initial page load)
		function updateModeIndicator(text) {
			const modeEl = document.getElementById('mode-indicator');
			if (!modeEl) return;

			// Check last few lines for INSERT mode
			const lines = text.split('\n').slice(-10).join('\n');
			const isInsert = lines.includes('-- INSERT --');

			if (isInsert) {
				modeEl.textContent = 'INS';
				modeEl.className = 'text-xs px-2 py-1 bg-green-600 text-white rounded font-medium shadow-sm';
			} else {
				modeEl.textContent = 'NOR';
				modeEl.className = 'text-xs px-2 py-1 bg-blue-600 text-white rounded font-medium shadow-sm';
			}
		}

		window.toggleMenu = function() {
			document.getElementById('menu').classList.toggle('hidden');
		}

		window.scrollToTop = function() {
			document.getElementById('output-container').scrollTop = 0;
			document.getElementById('menu').classList.add('hidden');
		}

		// Handle Enter vs Shift+Enter in input
		window.handleInputKeydown = function(e) {
			if (e.key === 'Enter' && !e.shiftKey) {
				e.preventDefault();
				document.getElementById('input-form').requestSubmit();
			}
		}

		// Auto-resize textarea
		window.autoResize = function(el) {
			el.style.height = 'auto';
			el.style.height = Math.min(el.scrollHeight, 120) + 'px';
		}

		document.addEventListener('click', function(e) {
			const menu = document.getElementById('menu');
			if (!e.target.closest('#menu') && !e.target.closest('[onclick="toggleMenu()"]')) {
				menu.classList.add('hidden');
			}
		});
	</script>
	<script src="/static/app.js"></script>
}

// PaneOutput renders just the pane output (for SSE updates)
templ PaneOutput(output string) {
	{ output }
}
