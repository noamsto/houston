package views

import (
	"fmt"
	"net/url"
	"time"

	"github.com/noams/tmux-dashboard/parser"
	"github.com/noams/tmux-dashboard/tmux"
)

// WindowWithStatus combines window info with its parse result
type WindowWithStatus struct {
	Window         tmux.Window
	ParseResult    parser.Result
	Preview        []string // Last 2-3 lines for preview
	NeedsAttention bool
}

// SessionWithWindows holds a session and all its windows with status
type SessionWithWindows struct {
	Session        tmux.Session
	Windows        []WindowWithStatus
	AttentionCount int  // Number of windows needing attention
	HasWorking     bool // At least one window is working
}

// SessionsData holds data for the sessions list
type SessionsData struct {
	NeedsAttention []SessionWithWindows // Sessions with windows needing attention
	Active         []SessionWithWindows // Sessions with working windows
	Idle           []SessionWithWindows // Sessions with all idle windows
}

// Legacy: keep for backward compatibility during transition
type SessionWithStatus struct {
	Session     tmux.Session
	ParseResult parser.Result
}

// PaneData holds data for the pane view
type PaneData struct {
	Pane        tmux.Pane
	Output      string
	ParseResult parser.Result
	Windows     []tmux.Window
	Panes       []tmux.PaneInfo
}

// Helper functions
func urlEncode(s string) string {
	return url.PathEscape(s)
}

func timeAgo(t time.Time) string {
	d := time.Since(t)
	switch {
	case d < time.Minute:
		return "just now"
	case d < time.Hour:
		return fmt.Sprintf("%dm ago", int(d.Minutes()))
	case d < 24*time.Hour:
		return fmt.Sprintf("%dh ago", int(d.Hours()))
	default:
		return t.Format("Jan 2")
	}
}

func truncate(s string, n int) string {
	if len(s) <= n {
		return s
	}
	return s[:n] + "..."
}

// lastLines returns the last n non-empty lines of a string
func lastLines(s string, n int) []string {
	lines := []string{}
	for _, line := range reverseStrings(splitLines(s)) {
		trimmed := trimLine(line)
		if trimmed != "" {
			lines = append([]string{trimmed}, lines...)
			if len(lines) >= n {
				break
			}
		}
	}
	return lines
}

func splitLines(s string) []string {
	result := []string{}
	start := 0
	for i := 0; i < len(s); i++ {
		if s[i] == '\n' {
			result = append(result, s[start:i])
			start = i + 1
		}
	}
	if start < len(s) {
		result = append(result, s[start:])
	}
	return result
}

func reverseStrings(ss []string) []string {
	result := make([]string, len(ss))
	for i, s := range ss {
		result[len(ss)-1-i] = s
	}
	return result
}

func trimLine(s string) string {
	// Trim leading/trailing whitespace but keep content
	start, end := 0, len(s)
	for start < end && (s[start] == ' ' || s[start] == '\t' || s[start] == '\r') {
		start++
	}
	for end > start && (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\r') {
		end--
	}
	return s[start:end]
}

// IndexPage renders the main dashboard page with Mission Control design
templ IndexPage() {
	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
		<title>tmux mission control</title>
		<link rel="preconnect" href="https://fonts.googleapis.com"/>
		<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet"/>
		<script src="https://unpkg.com/idiomorph@0.3.0/dist/idiomorph.min.js"></script>
		<style>
			:root {
				--bg-deep: #0a0a0b;
				--bg-panel: #111113;
				--bg-elevated: #1a1a1d;
				--border: #2a2a2e;
				--text-primary: #e4e4e7;
				--text-secondary: #71717a;
				--text-dim: #52525b;
				--attention: #f97316;
				--attention-glow: rgba(249, 115, 22, 0.4);
				--working: #22c55e;
				--working-glow: rgba(34, 197, 94, 0.3);
				--idle: #3f3f46;
				--accent: #06b6d4;
			}
			* { box-sizing: border-box; margin: 0; padding: 0; }
			body {
				font-family: 'IBM Plex Mono', ui-monospace, monospace;
				background: var(--bg-deep);
				color: var(--text-primary);
				min-height: 100vh;
				min-height: 100dvh;
			}
			.header {
				position: sticky;
				top: 0;
				background: var(--bg-deep);
				border-bottom: 1px solid var(--border);
				padding: 1rem;
				z-index: 100;
			}
			.header-content {
				display: flex;
				align-items: center;
				justify-content: space-between;
				max-width: 600px;
				margin: 0 auto;
			}
			.logo {
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}
			.logo-icon {
				width: 24px;
				height: 24px;
				background: var(--accent);
				border-radius: 4px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 10px;
				font-weight: 600;
				color: var(--bg-deep);
			}
			.logo-text {
				font-size: 14px;
				font-weight: 500;
				color: var(--text-secondary);
			}
			.main {
				max-width: 600px;
				margin: 0 auto;
				padding: 0.5rem;
				padding-bottom: 2rem;
			}
			.section-label {
				font-size: 10px;
				text-transform: uppercase;
				letter-spacing: 0.1em;
				color: var(--text-dim);
				padding: 1rem 0.5rem 0.5rem;
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}
			.section-label::after {
				content: '';
				flex: 1;
				height: 1px;
				background: var(--border);
			}
			.session {
				background: var(--bg-panel);
				border: 1px solid var(--border);
				border-radius: 8px;
				margin-bottom: 0.5rem;
				overflow: hidden;
			}
			.session.has-attention {
				border-color: var(--attention);
				box-shadow: 0 0 0 1px var(--attention-glow);
			}
			.session-header {
				display: flex;
				align-items: center;
				padding: 0.875rem 1rem;
				cursor: pointer;
				transition: background 0.15s;
			}
			.session-header:hover { background: var(--bg-elevated); }
			.session-indicator {
				width: 10px;
				height: 10px;
				border-radius: 50%;
				margin-right: 0.75rem;
				flex-shrink: 0;
			}
			.session-indicator.attention {
				background: var(--attention);
				box-shadow: 0 0 10px var(--attention-glow);
				animation: pulse 2s ease-in-out infinite;
			}
			.session-indicator.working {
				background: var(--working);
				box-shadow: 0 0 8px var(--working-glow);
			}
			.session-indicator.idle { background: var(--idle); }
			@keyframes pulse {
				0%, 100% { opacity: 1; transform: scale(1); }
				50% { opacity: 0.6; transform: scale(0.9); }
			}
			.session-info { flex: 1; min-width: 0; }
			.session-name {
				font-size: 14px;
				font-weight: 500;
				color: var(--text-primary);
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}
			.session-meta {
				font-size: 11px;
				color: var(--text-secondary);
				margin-top: 2px;
			}
			.session-badge {
				font-size: 10px;
				padding: 0.25rem 0.5rem;
				border-radius: 4px;
				background: var(--attention);
				color: var(--bg-deep);
				font-weight: 600;
				margin-left: 0.5rem;
			}
			.session-chevron {
				color: var(--text-dim);
				transition: transform 0.2s;
			}
			.session.expanded .session-chevron { transform: rotate(180deg); }
			.windows {
				border-top: 1px solid var(--border);
				background: var(--bg-deep);
			}
			.windows.hidden { display: none; }
			.window {
				display: flex;
				align-items: flex-start;
				padding: 0.75rem 1rem 0.75rem 2.5rem;
				border-bottom: 1px solid var(--border);
				cursor: pointer;
				transition: background 0.15s;
				text-decoration: none;
				color: inherit;
			}
			.window:last-child { border-bottom: none; }
			.window:hover { background: var(--bg-panel); }
			.window.attention { background: rgba(249, 115, 22, 0.05); }
			.window-indicator {
				width: 6px;
				height: 6px;
				border-radius: 50%;
				margin-right: 0.75rem;
				margin-top: 0.35rem;
				flex-shrink: 0;
			}
			.window-indicator.attention {
				background: var(--attention);
				box-shadow: 0 0 6px var(--attention-glow);
				animation: pulse 2s ease-in-out infinite;
			}
			.window-indicator.working { background: var(--working); }
			.window-indicator.idle { background: var(--idle); }
			.window-info { flex: 1; min-width: 0; }
			.window-name { font-size: 13px; color: var(--text-primary); }
			.window-status {
				font-size: 11px;
				color: var(--text-secondary);
				margin-top: 1px;
			}
			.window-status.attention { color: var(--attention); }
			.window-preview {
				margin-top: 0.5rem;
				padding: 0.5rem;
				background: rgba(0, 0, 0, 0.3);
				border-radius: 4px;
				font-size: 11px;
				line-height: 1.4;
				max-height: 4.5em;
				overflow: hidden;
			}
			.preview-line {
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				color: var(--text-secondary);
			}
			.window-arrow {
				color: var(--text-dim);
				font-size: 12px;
				margin-top: 0.25rem;
			}
			.empty-state {
				text-align: center;
				padding: 4rem 2rem;
				color: var(--text-secondary);
			}
			.empty-icon { font-size: 48px; margin-bottom: 1rem; opacity: 0.5; }
		</style>
	</head>
	<body>
		<header class="header">
			<div class="header-content">
				<div class="logo">
					<div class="logo-icon">MC</div>
					<span class="logo-text">mission control</span>
				</div>
			</div>
		</header>
		<main class="main">
			<div id="sessions">
				<div class="empty-state">
					<p>Loading...</p>
				</div>
			</div>
		</main>
		<script src="/static/app.js"></script>
		<script>
			// Track expanded sessions
			const expandedSessions = new Set();

			function toggleSession(header) {
				const session = header.closest('.session');
				const windows = session.querySelector('.windows');
				const sessionName = session.dataset.session;

				session.classList.toggle('expanded');
				windows.classList.toggle('hidden');

				// Track state
				if (session.classList.contains('expanded')) {
					expandedSessions.add(sessionName);
				} else {
					expandedSessions.delete(sessionName);
				}
			}

			// Restore expanded state after SSE update
			function restoreExpandedState() {
				document.querySelectorAll('.session').forEach(session => {
					const name = session.dataset.session;
					if (expandedSessions.has(name)) {
						session.classList.add('expanded');
						session.querySelector('.windows')?.classList.remove('hidden');
					}
				});
			}

			// Handle SSE manually for flicker-free updates
			function connectSSE() {
				const evtSource = new EventSource('/sessions?stream=1');
				const container = document.getElementById('sessions');

				evtSource.onmessage = function(e) {
					// Parse incoming HTML
					const temp = document.createElement('div');
					temp.innerHTML = e.data;

					// Pre-apply expanded state before morphing
					temp.querySelectorAll('.session').forEach(session => {
						const name = session.dataset.session;
						if (expandedSessions.has(name)) {
							session.classList.add('expanded');
							session.querySelector('.windows')?.classList.remove('hidden');
						}
					});

					// Use idiomorph to morph DOM (preserves hover, focus, etc.)
					Idiomorph.morph(container, temp.innerHTML, {
						morphStyle: 'innerHTML'
					});
				};

				evtSource.onerror = function() {
					console.log('SSE connection lost, reconnecting...');
					evtSource.close();
					setTimeout(connectSSE, 3000);
				};
			}

			// Start SSE connection
			connectSSE();
		</script>
	</body>
	</html>
}

// Sessions renders the sessions list with window-level detail
templ Sessions(data SessionsData) {
	// Needs Attention section
	if len(data.NeedsAttention) > 0 {
		<div class="section-label">Needs attention</div>
		for _, sess := range data.NeedsAttention {
			@sessionCardV2(sess, true)
		}
	}
	// Active section
	if len(data.Active) > 0 {
		<div class="section-label">Active</div>
		for _, sess := range data.Active {
			@sessionCardV2(sess, false)
		}
	}
	// Idle section
	if len(data.Idle) > 0 {
		<div class="section-label">Idle</div>
		for _, sess := range data.Idle {
			@sessionCardV2(sess, false)
		}
	}
	// Empty state
	if len(data.NeedsAttention) == 0 && len(data.Active) == 0 && len(data.Idle) == 0 {
		<div class="empty-state">
			<div class="empty-icon">◯</div>
			<p>No tmux sessions</p>
		</div>
	}
}

// sessionCardV2 renders a session with its windows
templ sessionCardV2(sess SessionWithWindows, expanded bool) {
	<div class={ "session", templ.KV("has-attention", sess.AttentionCount > 0), templ.KV("expanded", expanded) } data-session={ sess.Session.Name }>
		<div class="session-header" onclick="toggleSession(this)">
			<div class={ "session-indicator", getSessionIndicator(sess) }></div>
			<div class="session-info">
				<div class="session-name">{ sess.Session.Name }</div>
				<div class="session-meta">{ fmt.Sprintf("%d windows", len(sess.Windows)) }</div>
			</div>
			if sess.AttentionCount > 0 {
				<span class="session-badge">{ fmt.Sprintf("%d", sess.AttentionCount) }</span>
			}
			<svg class="session-chevron" width="20" height="20" viewBox="0 0 20 20" fill="none">
				<path d="M5 7.5L10 12.5L15 7.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path>
			</svg>
		</div>
		<div class={ "windows", templ.KV("hidden", !expanded) }>
			for _, win := range sess.Windows {
				@windowCard(sess.Session.Name, win)
			}
		</div>
	</div>
}

// windowCard renders a single window within a session
templ windowCard(sessionName string, win WindowWithStatus) {
	<a
		href={ templ.SafeURL("/pane/" + urlEncode(sessionName) + ":" + fmt.Sprintf("%d", win.Window.Index)) }
		class={ "window", templ.KV("attention", win.NeedsAttention) }
	>
		<div class={ "window-indicator", getWindowIndicator(win) }></div>
		<div class="window-info">
			<div class="window-name">{ fmt.Sprintf("%d: %s", win.Window.Index, win.Window.Name) }</div>
			<div class={ "window-status", templ.KV("attention", win.NeedsAttention) }>
				{ getWindowStatusText(win) }
			</div>
			if len(win.Preview) > 0 {
				<div class="window-preview">
					for _, line := range win.Preview {
						<div class="preview-line">{ line }</div>
					}
				</div>
			}
		</div>
		<span class="window-arrow">→</span>
	</a>
}

// Helper functions for template
func getSessionIndicator(sess SessionWithWindows) string {
	if sess.AttentionCount > 0 {
		return "attention"
	}
	if sess.HasWorking {
		return "working"
	}
	return "idle"
}

func getWindowIndicator(win WindowWithStatus) string {
	if win.NeedsAttention {
		return "attention"
	}
	if win.ParseResult.Type == parser.TypeWorking {
		return "working"
	}
	return "idle"
}

func getWindowStatusText(win WindowWithStatus) string {
	switch win.ParseResult.Type {
	case parser.TypeError:
		return "Error"
	case parser.TypeChoice:
		return "Waiting for choice..."
	case parser.TypeQuestion:
		if win.ParseResult.Question != "" {
			q := win.ParseResult.Question
			if len(q) > 40 {
				q = q[:37] + "..."
			}
			return q
		}
		return "Waiting for input..."
	case parser.TypeWorking:
		return "Working..."
	default:
		return "Idle"
	}
}

// PanePage renders the pane view
templ PanePage(data PaneData) {
	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>{ data.Pane.Session } - tmux-dashboard</title>
		<script src="https://cdn.tailwindcss.com"></script>
		<script src="https://unpkg.com/htmx.org@1.9.10"></script>
		<script src="https://unpkg.com/htmx.org@1.9.10/dist/ext/sse.js"></script>
		<style>
			.terminal {
				font-family: ui-monospace, monospace;
				-webkit-user-select: text;
				user-select: text;
				cursor: text;
			}
			/* Diff highlighting - inline to avoid extra newlines in pre */
			.diff-add {
				background-color: rgba(34, 197, 94, 0.25);
			}
			.diff-del {
				background-color: rgba(239, 68, 68, 0.25);
			}
			.diff-hunk {
				background-color: rgba(59, 130, 246, 0.25);
			}
		</style>
	</head>
	<body class="bg-gray-100 min-h-screen">
		<div class="flex flex-col h-screen max-w-lg mx-auto">
			<!-- Header -->
			<header class="flex items-center gap-3 p-4 bg-white border-b">
				<a href="/" class="p-2 -ml-2 hover:bg-gray-100 rounded">
					<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
					</svg>
				</a>
				<h1 class="font-medium text-gray-900 flex-1">{ data.Pane.Session }</h1>
				<div class="relative">
					<button class="p-2 hover:bg-gray-100 rounded" onclick="toggleMenu()">
						<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"></path>
						</svg>
					</button>
					<div id="menu" class="hidden absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg border z-10">
						<button
							hx-post={ "/pane/" + data.Pane.URLTarget() + "/send" }
							hx-vals='{"input": "C-c", "special": "true"}'
							class="w-full text-left px-4 py-2 hover:bg-gray-100"
						>Send Ctrl+C</button>
						<button
							onclick="scrollToTop()"
							class="w-full text-left px-4 py-2 hover:bg-gray-100"
						>Scroll to top</button>
						<button
							hx-get={ "/pane/" + data.Pane.URLTarget() }
							hx-target="#output"
							hx-swap="innerHTML"
							class="w-full text-left px-4 py-2 hover:bg-gray-100"
						>Refresh</button>
					</div>
				</div>
			</header>
			<!-- Window/Pane selector -->
			if len(data.Windows) > 1 || len(data.Panes) > 1 {
				<div class="flex gap-2 p-2 bg-gray-200 border-b text-sm overflow-x-auto">
					if len(data.Windows) > 1 {
						for _, w := range data.Windows {
							<a
								href={ templ.SafeURL("/pane/" + urlEncode(data.Pane.Session) + ":" + fmt.Sprintf("%d", w.Index)) }
								class={ "px-3 py-1 rounded whitespace-nowrap", templ.KV("bg-blue-500 text-white", w.Index == data.Pane.Window), templ.KV("bg-white hover:bg-gray-100", w.Index != data.Pane.Window) }
							>
								{ fmt.Sprintf("%d: %s", w.Index, w.Name) }
							</a>
						}
					}
					if len(data.Panes) > 1 {
						<span class="text-gray-400 px-1">|</span>
						for _, p := range data.Panes {
							<a
								href={ templ.SafeURL("/pane/" + urlEncode(data.Pane.Session) + ":" + fmt.Sprintf("%d.%d", data.Pane.Window, p.Index)) }
								class={ "px-2 py-1 rounded whitespace-nowrap", templ.KV("bg-green-500 text-white", p.Index == data.Pane.Index), templ.KV("bg-white hover:bg-gray-100", p.Index != data.Pane.Index) }
							>
								{ fmt.Sprintf("P%d", p.Index) }
								<span class="text-xs opacity-70">{ p.Command }</span>
							</a>
						}
					}
				</div>
			}
			<!-- Output area -->
			<div
				id="output-container"
				class="flex-1 overflow-y-auto bg-gray-900"
				hx-ext="sse"
				sse-connect={ "/pane/" + data.Pane.URLTarget() + "?stream=1" }
				sse-swap="message"
				hx-target="#output"
				hx-swap="none"
			>
				<pre id="output" class="terminal text-sm text-gray-100 p-4 whitespace-pre overflow-x-auto min-w-full bg-gray-900">{ data.Output }</pre>
			</div>
			if len(data.ParseResult.Choices) > 0 {
				<!-- Quick choice buttons -->
				<div class="flex gap-2 p-3 bg-gray-800 border-t border-gray-700">
					for i := range data.ParseResult.Choices {
						if i < 4 {
							<button
								hx-post={ "/pane/" + data.Pane.URLTarget() + "/send" }
								hx-vals={ fmt.Sprintf(`{"input": "%d", "noenter": "true"}`, i+1) }
								hx-swap="none"
								hx-on::after-request="setTimeout(() => { const c = document.getElementById('output-container'); c.scrollTop = c.scrollHeight; }, 100)"
								class="flex-1 px-3 py-2 text-sm bg-gray-700 hover:bg-gray-600 text-white rounded"
							>{ fmt.Sprintf("%d", i+1) }</button>
						}
					}
				</div>
			}
			<!-- Input bar -->
			<form
				id="input-form"
				hx-post={ "/pane/" + data.Pane.URLTarget() + "/send" }
				hx-swap="none"
				hx-on::after-request="this.reset(); document.getElementById('input-field').style.height = 'auto';"
				class="flex gap-2 p-3 bg-white border-t items-center"
			>
				if data.ParseResult.Mode.String() == "insert" {
					<span id="mode-indicator" class="text-xs px-2 py-1 bg-green-600 text-white rounded font-medium shadow-sm">INS</span>
				} else {
					<span id="mode-indicator" class="text-xs px-2 py-1 bg-blue-600 text-white rounded font-medium shadow-sm">NOR</span>
				}
				<textarea
					id="input-field"
					name="input"
					placeholder="Send input... (Shift+Enter for newline)"
					autocomplete="off"
					rows="1"
					class="flex-1 px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
					onkeydown="handleInputKeydown(event)"
					oninput="autoResize(this)"
				></textarea>
				<!-- Stop button -->
				<button
					type="button"
					hx-post={ "/pane/" + data.Pane.URLTarget() + "/send" }
					hx-vals='{"input": "C-c", "special": "true"}'
					hx-swap="none"
					class="p-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
					title="Stop (Ctrl+C)"
				>
					<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
					</svg>
				</button>
				<!-- Send button -->
				<button
					type="submit"
					class="p-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600"
					title="Send"
				>
					<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"></path>
					</svg>
				</button>
			</form>
		</div>
		@paneScripts()
	</body>
	</html>
}

// paneScripts contains the JavaScript for the pane page
templ paneScripts() {
	<script type="module">
		import { AnsiUp } from 'https://cdn.jsdelivr.net/npm/ansi_up@6/ansi_up.js';

		const ansiUp = new AnsiUp();
		ansiUp.escapeHtml = true;  // Ensure HTML is escaped (v6 uses camelCase)

		// Strip ANSI background colors from ansi_up output
		// Only target rgb() values (ansi_up uses rgb, not rgba) to avoid stripping CSS code in terminal content
		function fixBackgrounds(html) {
			html = html.replace(/background-color:\s*rgb\([^)]+\);?/gi, '');
			return html;
		}

		// Add subtle backgrounds for diff lines
		// Claude Code format: "703 +  code" or "703 -  code" (line number, space, +/-, space, code)
		function enhanceDiffs(html) {
			const lines = html.split('\n');
			return lines.map(line => {
				const stripped = line.replace(/<[^>]*>/g, ''); // Strip HTML tags to check content
				// Match Claude Code diff format: line_number +/- code
				const match = stripped.match(/^\s*\d+\s+([-+])\s/);
				if (match) {
					if (match[1] === '+') {
						return '<span class="diff-add">' + line + '</span>';
					} else {
						return '<span class="diff-del">' + line + '</span>';
					}
				}
				// Also match standard diff format (starts with +/- directly)
				if (stripped.startsWith('+') && !stripped.startsWith('+++')) {
					return '<span class="diff-add">' + line + '</span>';
				} else if (stripped.startsWith('-') && !stripped.startsWith('---')) {
					return '<span class="diff-del">' + line + '</span>';
				} else if (stripped.startsWith('@@')) {
					return '<span class="diff-hunk">' + line + '</span>';
				}
				return line;
			}).join('\n');
		}

		function processOutput(text) {
			try {
				// Normalize line endings and remove carriage returns
				text = text.replace(/\r\n/g, '\n').replace(/\r/g, '');
				let html = ansiUp.ansi_to_html(text);
				html = fixBackgrounds(html);
				html = enhanceDiffs(html);
				return html;
			} catch (err) {
				console.error('ansi_up error:', err);
				// Fallback: escape HTML and preserve newlines
				return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
			}
		}

		document.addEventListener('DOMContentLoaded', function() {
			const container = document.getElementById('output-container');
			if (container) {
				container.scrollTop = container.scrollHeight;
			}
			const output = document.getElementById('output');
			if (output) {
				output.innerHTML = processOutput(output.textContent);
			}
		});

		// Handle SSE messages manually to prevent htmx from setting innerHTML directly
		// This prevents terminal content with HTML-like text from being rendered as actual HTML
		document.body.addEventListener('htmx:sseMessage', function(e) {
			console.debug('SSE message received', e.detail.data?.length || 0, 'bytes');
			const output = document.getElementById('output');
			if (!output) return;

			const container = document.getElementById('output-container');
			// Check if user is at the bottom before updating (with 50px threshold)
			const wasAtBottom = container &&
				(container.scrollTop + container.clientHeight >= container.scrollHeight - 50);

			// Get the raw text from SSE (already safe as plain text)
			let text = e.detail.data;

			// Extract mode from special first line if present
			const modeMatch = text.match(/^__MODE__:(\w*)\n/);
			if (modeMatch) {
				const mode = modeMatch[1];
				text = text.substring(modeMatch[0].length);
				updateModeIndicatorDirect(mode);
			}

			// Process with ansi_up (which has escapeHtml enabled)
			output.innerHTML = processOutput(text);

			// Only auto-scroll if user was already at the bottom
			if (wasAtBottom && container) {
				container.scrollTop = container.scrollHeight;
			}
		});

		// Log SSE connection events
		document.body.addEventListener('htmx:sseOpen', function(e) {
			console.log('SSE connected');
		});

		document.body.addEventListener('htmx:sseError', function(e) {
			console.warn('SSE error', e.detail);
		});

		// Update mode indicator based on mode string from server
		function updateModeIndicatorDirect(mode) {
			const modeEl = document.getElementById('mode-indicator');
			if (!modeEl) return;

			if (mode === 'insert') {
				modeEl.textContent = 'INS';
				modeEl.className = 'text-xs px-2 py-1 bg-green-600 text-white rounded font-medium shadow-sm';
			} else {
				modeEl.textContent = 'NOR';
				modeEl.className = 'text-xs px-2 py-1 bg-blue-600 text-white rounded font-medium shadow-sm';
			}
		}

		// Fallback: Update mode indicator by parsing text (for initial page load)
		function updateModeIndicator(text) {
			const modeEl = document.getElementById('mode-indicator');
			if (!modeEl) return;

			// Check last few lines for INSERT mode
			const lines = text.split('\n').slice(-10).join('\n');
			const isInsert = lines.includes('-- INSERT --');

			if (isInsert) {
				modeEl.textContent = 'INS';
				modeEl.className = 'text-xs px-2 py-1 bg-green-600 text-white rounded font-medium shadow-sm';
			} else {
				modeEl.textContent = 'NOR';
				modeEl.className = 'text-xs px-2 py-1 bg-blue-600 text-white rounded font-medium shadow-sm';
			}
		}

		window.toggleMenu = function() {
			document.getElementById('menu').classList.toggle('hidden');
		}

		window.scrollToTop = function() {
			document.getElementById('output-container').scrollTop = 0;
			document.getElementById('menu').classList.add('hidden');
		}

		// Handle Enter vs Shift+Enter in input
		window.handleInputKeydown = function(e) {
			if (e.key === 'Enter' && !e.shiftKey) {
				e.preventDefault();
				document.getElementById('input-form').requestSubmit();
			}
		}

		// Auto-resize textarea
		window.autoResize = function(el) {
			el.style.height = 'auto';
			el.style.height = Math.min(el.scrollHeight, 120) + 'px';
		}

		document.addEventListener('click', function(e) {
			const menu = document.getElementById('menu');
			if (!e.target.closest('#menu') && !e.target.closest('[onclick="toggleMenu()"]')) {
				menu.classList.add('hidden');
			}
		});
	</script>
	<script src="/static/app.js"></script>
}

// PaneOutput renders just the pane output (for SSE updates)
templ PaneOutput(output string) {
	{ output }
}
