package views

import (
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/noamsto/houston/parser"
	"github.com/noamsto/houston/tmux"
)

// WindowWithStatus combines window info with its parse result
type WindowWithStatus struct {
	Window         tmux.Window
	Pane           tmux.Pane // The pane being monitored
	ParseResult    parser.Result
	Preview        []string // Last 2-3 lines for preview
	NeedsAttention bool
	Branch         string // Git branch name (from worktree or git command)
	Process        string // Running process (pane_current_command)
}

// SessionWithWindows holds a session and all its windows with status
type SessionWithWindows struct {
	Session        tmux.Session
	Windows        []WindowWithStatus
	AttentionCount int  // Number of windows needing attention
	HasWorking     bool // At least one window is working
}

// SessionsData holds data for the sessions list
type SessionsData struct {
	NeedsAttention []SessionWithWindows // Sessions with windows needing attention
	Active         []SessionWithWindows // Sessions with working windows
	Idle           []SessionWithWindows // Sessions with all idle windows
}

// Legacy: keep for backward compatibility during transition
type SessionWithStatus struct {
	Session     tmux.Session
	ParseResult parser.Result
}

// PaneData holds data for the pane view
type PaneData struct {
	Pane        tmux.Pane
	Output      string
	ParseResult parser.Result
	Windows     []tmux.Window
	Panes       []tmux.PaneInfo
}

// Helper functions
func urlEncode(s string) string {
	return url.PathEscape(s)
}

func timeAgo(t time.Time) string {
	d := time.Since(t)
	switch {
	case d < time.Minute:
		return "just now"
	case d < time.Hour:
		return fmt.Sprintf("%dm ago", int(d.Minutes()))
	case d < 24*time.Hour:
		return fmt.Sprintf("%dh ago", int(d.Hours()))
	default:
		return t.Format("Jan 2")
	}
}

func truncate(s string, n int) string {
	if len(s) <= n {
		return s
	}
	return s[:n] + "..."
}

// lastLines returns the last n non-empty lines of a string
func lastLines(s string, n int) []string {
	lines := []string{}
	for _, line := range reverseStrings(splitLines(s)) {
		trimmed := trimLine(line)
		if trimmed != "" {
			lines = append([]string{trimmed}, lines...)
			if len(lines) >= n {
				break
			}
		}
	}
	return lines
}

func splitLines(s string) []string {
	result := []string{}
	start := 0
	for i := 0; i < len(s); i++ {
		if s[i] == '\n' {
			result = append(result, s[start:i])
			start = i + 1
		}
	}
	if start < len(s) {
		result = append(result, s[start:])
	}
	return result
}

func reverseStrings(ss []string) []string {
	result := make([]string, len(ss))
	for i, s := range ss {
		result[len(ss)-1-i] = s
	}
	return result
}

func trimLine(s string) string {
	// Trim leading/trailing whitespace but keep content
	start, end := 0, len(s)
	for start < end && (s[start] == ' ' || s[start] == '\t' || s[start] == '\r') {
		start++
	}
	for end > start && (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\r') {
		end--
	}
	return s[start:end]
}

// IndexPage renders the main dashboard page with Mission Control design
templ IndexPage() {
	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
		<link rel="icon" type="image/svg+xml" href="/static/favicon.svg"/>
		<title>mission control</title>
		<link rel="preconnect" href="https://fonts.googleapis.com"/>
		<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet"/>
		<!-- Nerd Font for terminal icons -->
		<link href="https://cdn.jsdelivr.net/gh/mshaugh/nerdfont-webfonts@v3.3.0/build/symbols-nerd-font-mono.css" rel="stylesheet"/>
		<script src="https://unpkg.com/idiomorph@0.3.0/dist/idiomorph.min.js"></script>
		<style>
			:root {
				--bg-deep: #0a0a0b;
				--bg-panel: #111113;
				--bg-elevated: #1a1a1d;
				--border: #2a2a2e;
				--text-primary: #e4e4e7;
				--text-secondary: #a1a1aa;
				--text-dim: #71717a;
				--text-preview: #9ca3af;
				--attention: #f97316;
			}
			[data-theme="light"] {
				--bg-deep: #f4f4f5;
				--bg-panel: #ffffff;
				--bg-elevated: #e4e4e7;
				--border: #d4d4d8;
				--text-primary: #18181b;
				--text-secondary: #52525b;
				--text-dim: #71717a;
				--text-preview: #4b5563;
				--attention: #ea580c;
				--attention-glow: rgba(234, 88, 12, 0.25);
				--error: #dc2626;
				--error-glow: rgba(220, 38, 38, 0.25);
				--working: #16a34a;
				--working-glow: rgba(22, 163, 74, 0.2);
				--idle: #a1a1aa;
				--accent: #0891b2;
				--accent-dim: rgba(8, 145, 178, 0.12);
			}
			[data-theme="light"] body::before {
				background: none; /* Disable scan lines in light mode */
			}
			* { box-sizing: border-box; margin: 0; padding: 0; }
			body {
				font-family: 'IBM Plex Mono', 'Symbols Nerd Font Mono', ui-monospace, monospace;
				background: var(--bg-deep);
				color: var(--text-primary);
				min-height: 100vh;
				min-height: 100dvh;
			}
			/* Scan line overlay */
			body::before {
				content: '';
				position: fixed;
				top: 0; left: 0; right: 0; bottom: 0;
				background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px);
				pointer-events: none;
				z-index: 1000;
			}
			.header {
				position: sticky;
				top: 0;
				background: var(--bg-deep);
				border-bottom: 1px solid var(--border);
				padding: 1rem;
				z-index: 100;
			}
			.header-content {
				display: flex;
				align-items: center;
				justify-content: space-between;
				max-width: 600px;
				margin: 0 auto;
			}
			.search-bar {
				padding: 0 1rem 0.75rem;
				max-width: 600px;
				margin: 0 auto;
			}
			.search-input {
				width: 100%;
				background: var(--bg-elevated);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 0.5rem 0.75rem 0.5rem 2.25rem;
				font-family: inherit;
				font-size: 14px;
				color: var(--text-primary);
				outline: none;
				background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23555566'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'/%3E%3C/svg%3E");
				background-repeat: no-repeat;
				background-position: 0.625rem center;
				background-size: 16px;
			}
			.search-input:focus {
				border-color: var(--accent);
				box-shadow: 0 0 0 2px var(--accent-dim);
			}
			.search-input::placeholder { color: var(--text-dim); }
			.logo {
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}
			.logo-icon {
				width: 24px;
				height: 24px;
				background: var(--accent);
				border-radius: 4px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 10px;
				font-weight: 600;
				color: var(--bg-deep);
			}
			.logo-text {
				font-size: 14px;
				font-weight: 500;
				color: var(--text-secondary);
			}
			.status-summary {
				display: flex;
				align-items: center;
				gap: 1rem;
				font-size: 11px;
			}
			.status-count {
				display: flex;
				align-items: center;
				gap: 0.35rem;
			}
			.status-dot {
				width: 8px;
				height: 8px;
				border-radius: 50%;
			}
			.status-dot.attention {
				background: var(--attention);
				box-shadow: 0 0 8px var(--attention-glow);
			}
			.status-dot.working {
				background: var(--working);
				box-shadow: 0 0 6px var(--working-glow);
			}
			.status-dot.idle {
				background: var(--idle);
			}
			.header-right {
				display: flex;
				align-items: center;
				gap: 0.75rem;
			}
			.notification-btn {
				background: none;
				border: none;
				cursor: pointer;
				padding: 0.25rem;
				transition: opacity 0.15s;
				display: flex;
				align-items: center;
			}
			.notification-btn:hover { opacity: 1; }
			.notification-btn svg {
				width: 18px;
				height: 18px;
			}
			.notification-btn .bell-off { stroke: var(--text-dim); }
			.notification-btn .bell-on { stroke: var(--working); }
			.theme-toggle {
				background: none;
				border: none;
				cursor: pointer;
				padding: 0.25rem;
				display: flex;
				align-items: center;
				position: relative;
				width: 20px;
				height: 20px;
			}
			.theme-toggle svg {
				width: 18px;
				height: 18px;
				position: absolute;
				transition: transform 0.3s ease, opacity 0.3s ease;
			}
			.theme-toggle .sun-icon {
				stroke: var(--text-dim);
				opacity: 0;
				transform: rotate(-90deg) scale(0.5);
			}
			.theme-toggle .moon-icon {
				stroke: var(--text-dim);
				opacity: 1;
				transform: rotate(0deg) scale(1);
			}
			.theme-toggle:hover svg { stroke: var(--text-primary); }
			[data-theme="light"] .theme-toggle .sun-icon {
				opacity: 1;
				transform: rotate(0deg) scale(1);
			}
			[data-theme="light"] .theme-toggle .moon-icon {
				opacity: 0;
				transform: rotate(90deg) scale(0.5);
			}
			.main {
				max-width: 600px;
				margin: 0 auto;
				padding: 0.5rem;
				padding-bottom: 2rem;
			}
			.section-label {
				font-size: 10px;
				text-transform: uppercase;
				letter-spacing: 0.1em;
				color: var(--text-dim);
				padding: 1rem 0.5rem 0.5rem;
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}
			.section-label::after {
				content: '';
				flex: 1;
				height: 1px;
				background: var(--border);
			}
			.session {
				background: var(--bg-panel);
				border: 1px solid var(--border);
				border-radius: 8px;
				margin-bottom: 0.5rem;
				overflow: hidden;
			}
			.session.has-attention {
				border-color: var(--attention);
				box-shadow: 0 0 0 1px var(--attention-glow);
			}
			.session-header {
				display: flex;
				align-items: center;
				padding: 0.875rem 1rem;
				cursor: pointer;
				transition: background 0.15s;
			}
			.session-header:hover { background: var(--bg-elevated); }
			.session-indicator {
				width: 10px;
				height: 10px;
				border-radius: 50%;
				margin-right: 0.75rem;
				flex-shrink: 0;
			}
			.session-indicator.attention {
				background: var(--attention);
				box-shadow: 0 0 10px var(--attention-glow);
				animation: pulse 2s ease-in-out infinite;
			}
			.session-indicator.error {
				background: var(--error);
				box-shadow: 0 0 10px var(--error-glow);
				animation: pulse 1.5s ease-in-out infinite;
			}
			.session-indicator.working {
				background: var(--working);
				box-shadow: 0 0 8px var(--working-glow);
			}
			.session-indicator.idle { background: var(--idle); }
			@keyframes pulse {
				0%, 100% { opacity: 1; transform: scale(1); }
				50% { opacity: 0.6; transform: scale(0.9); }
			}
			.session-info { flex: 1; min-width: 0; }
			.session-name {
				font-size: 14px;
				font-weight: 500;
				color: var(--text-primary);
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}
			.session-meta {
				font-size: 11px;
				color: var(--text-secondary);
				margin-top: 2px;
			}
			.session-badge {
				font-size: 10px;
				padding: 0.25rem 0.5rem;
				border-radius: 4px;
				background: var(--attention);
				color: var(--bg-deep);
				font-weight: 600;
				margin-left: 0.5rem;
			}
			.dismiss-btn {
				background: var(--bg-elevated);
				border: 1px solid var(--border);
				color: var(--text-secondary);
				padding: 0.375rem 0.625rem;
				margin-left: 0.5rem;
				cursor: pointer;
				font-size: 11px;
				font-weight: 500;
				border-radius: 6px;
				transition: all 0.15s;
			}
			.dismiss-btn:hover {
				background: rgba(249, 115, 22, 0.15);
				border-color: var(--attention);
				color: var(--attention);
			}
			.session-chevron {
				color: var(--text-dim);
				transition: transform 0.2s;
			}
			.session.expanded .session-chevron { transform: rotate(180deg); }
			.windows {
				border-top: 1px solid var(--border);
				background: var(--bg-deep);
			}
			.windows.hidden { display: none; }
			.window {
				display: flex;
				align-items: flex-start;
				padding: 0.75rem 1rem 0.75rem 2.5rem;
				border-bottom: 1px solid var(--border);
				cursor: pointer;
				transition: background 0.15s;
				text-decoration: none;
				color: inherit;
			}
			.window:last-child { border-bottom: none; }
			.window:hover { background: var(--bg-panel); }
			.window.attention { background: rgba(249, 115, 22, 0.05); }
			.window-indicator {
				width: 6px;
				height: 6px;
				border-radius: 50%;
				margin-right: 0.75rem;
				margin-top: 0.35rem;
				flex-shrink: 0;
			}
			.window-indicator.attention {
				background: var(--attention);
				box-shadow: 0 0 6px var(--attention-glow);
				animation: pulse 2s ease-in-out infinite;
			}
			.window-indicator.error {
				background: var(--error);
				box-shadow: 0 0 6px var(--error-glow);
				animation: pulse 1.5s ease-in-out infinite;
			}
			.window-indicator.working { background: var(--working); }
			.window-indicator.idle { background: var(--idle); }
			.window-info { flex: 1; min-width: 0; }
			.window-name { font-size: 13px; color: var(--text-primary); }
			.window-status {
				font-size: 11px;
				color: var(--text-secondary);
				margin-top: 1px;
			}
			.window-status.idle { color: var(--text-dim); }
			.window-status.working { color: var(--working); }
			.window-status.attention { color: var(--attention); }
			.window-preview {
				margin-top: 0.5rem;
				padding: 0.5rem 0.625rem;
				background: rgba(0, 0, 0, 0.4);
				border-radius: 4px;
				font-size: 11px;
				line-height: 1.5;
				max-height: 4.5em;
				overflow: hidden;
				border-left: 2px solid var(--border);
			}
			.preview-line {
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				color: var(--text-preview);
			}
			.window-actions {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 0.25rem;
				flex-shrink: 0;
			}
			.window-view-btn {
				color: var(--accent);
				text-decoration: none;
				font-size: 11px;
				font-weight: 500;
				text-transform: uppercase;
				letter-spacing: 0.5px;
				padding: 0.375rem 0.75rem;
				border-radius: 6px;
				transition: all 0.15s;
				background: var(--accent-dim);
				border: 1px solid var(--accent);
			}
			.window-view-btn:hover, .window-view-btn:active {
				background: var(--accent);
				color: var(--bg-deep);
			}
			.window-arrow {
				color: var(--text-dim);
				font-size: 12px;
			}
			.empty-state {
				text-align: center;
				padding: 4rem 2rem;
				color: var(--text-secondary);
			}
			.empty-icon { font-size: 48px; margin-bottom: 1rem; opacity: 0.5; }
			/* Action bar */
			.action-backdrop {
				position: fixed;
				inset: 0;
				background: rgba(0, 0, 0, 0.5);
				opacity: 0;
				visibility: hidden;
				transition: opacity 0.3s, visibility 0.3s;
				z-index: 190;
			}
			.action-backdrop.visible {
				opacity: 1;
				visibility: visible;
			}
			.action-bar {
				position: fixed;
				bottom: 0;
				left: 0;
				right: 0;
				background: var(--bg-panel);
				border-top: 1px solid var(--border);
				padding: 0.5rem;
				padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));
				transform: translateY(100%);
				transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
				z-index: 200;
			}
			.action-bar.visible { transform: translateY(0); }
			.action-bar-content {
				max-width: 100%;
			}
			.action-target {
				font-size: 11px;
				color: var(--text-secondary);
				margin-bottom: 0.5rem;
				display: flex;
				align-items: center;
				justify-content: space-between;
			}
			.action-close {
				background: none;
				border: none;
				color: var(--text-dim);
				cursor: pointer;
				padding: 0.25rem;
				font-size: 14px;
			}
			.action-input-row {
				display: flex;
				gap: 0.375rem;
			}
			.action-input {
				flex: 1;
				min-width: 0;
				background: var(--bg-deep);
				border: 1px solid var(--border);
				border-radius: 6px;
				padding: 0.5rem 0.75rem;
				font-family: inherit;
				font-size: 16px; /* Prevents iOS zoom on focus */
				color: var(--text-primary);
				outline: none;
			}
			.action-input:focus {
				border-color: var(--accent);
				box-shadow: 0 0 0 2px var(--accent-dim);
			}
			.action-input::placeholder { color: var(--text-dim); }
			.action-btn {
				background: var(--accent);
				border: none;
				border-radius: 6px;
				padding: 0.5rem 0.75rem;
				font-family: inherit;
				font-size: 13px;
				font-weight: 500;
				color: var(--bg-deep);
				cursor: pointer;
				transition: opacity 0.15s;
				flex-shrink: 0;
				white-space: nowrap;
			}
			.action-btn:active { opacity: 0.8; }
			.action-btn.stop {
				background: var(--error);
				color: white;
				padding: 0.5rem;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.action-btn.view {
				background: #3b82f6;
				color: white;
			}
			.action-context {
				margin-bottom: 0.5rem;
				padding: 0.5rem;
				background: var(--bg-deep);
				border-radius: 6px;
				border-left: 3px solid var(--idle);
			}
			.action-context.attention { border-left-color: var(--attention); }
			.action-context.working { border-left-color: var(--working); }
			.action-status {
				font-size: 12px;
				font-weight: 500;
				margin-bottom: 0.5rem;
			}
			.action-status.attention { color: var(--attention); }
			.action-status.working { color: var(--working); }
			.action-preview {
				font-size: 11px;
				color: var(--text-secondary);
				line-height: 1.4;
				max-height: 12em;
				overflow-y: auto;
			}
			.action-preview-line {
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}
			.action-choices {
				display: flex;
				gap: 0.5rem;
				margin-bottom: 0.75rem;
			}
			.action-choices.hidden { display: none; }
			.choice-btn {
				flex: 1;
				padding: 0.625rem 0.5rem;
				background: var(--bg-elevated);
				border: 1px solid var(--border);
				border-radius: 6px;
				color: var(--text-primary);
				font-family: inherit;
				font-size: 12px;
				cursor: pointer;
				transition: all 0.15s;
				text-align: center;
				line-height: 1.3;
			}
			.choice-btn:hover {
				background: var(--accent-dim);
				border-color: var(--accent);
			}
			.choice-btn:active { transform: scale(0.98); }
			.choice-num {
				display: block;
				font-size: 14px;
				font-weight: 600;
				color: var(--accent);
				margin-bottom: 2px;
			}

			/* Sessions grid - mobile first (single column) */
			.sessions-grid {
				display: flex;
				flex-direction: column;
				gap: 0.5rem;
			}
			.empty-state {
				grid-column: 1 / -1;
			}

			/* ============================================
			   DESKTOP RESPONSIVE STYLES
			   ============================================ */

			/* Tablet breakpoint */
			@media (min-width: 768px) {
				.header-content {
					max-width: 720px;
				}
				.search-bar {
					max-width: 720px;
				}
				.main {
					max-width: 720px;
					padding: 1rem;
				}
				.session-header {
					padding: 1rem 1.25rem;
				}
				.window {
					padding: 0.875rem 1.25rem 0.875rem 2.75rem;
				}
				.window-preview {
					max-height: 6em;
				}
			}

			/* Desktop breakpoint */
			@media (min-width: 1024px) {
				.header-content {
					max-width: 1200px;
				}
				.search-bar {
					max-width: 1200px;
				}
				.main {
					max-width: 1200px;
					padding: 1.5rem 2rem;
				}
				/* Grid layout for sessions on desktop */
				.sessions-grid {
					display: grid;
					grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
					gap: 1rem;
				}
				.session {
					margin-bottom: 0;
				}
				.section-label {
					grid-column: 1 / -1;
					padding: 0.5rem 0;
				}
				/* Larger window previews */
				.window-preview {
					max-height: 8em;
					font-size: 12px;
				}
				.window-info {
					min-width: 200px;
				}
				/* Desktop action bar as side panel */
				.action-bar {
					position: fixed;
					bottom: auto;
					top: 50%;
					right: 1.5rem;
					left: auto;
					transform: translateX(120%) translateY(-50%);
					width: 400px;
					max-width: calc(100vw - 3rem);
					border-radius: 12px;
					border: 1px solid var(--border);
					box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
					padding: 1rem;
					padding-bottom: 1rem;
				}
				.action-bar.visible {
					transform: translateX(0) translateY(-50%);
				}
				.action-backdrop {
					background: rgba(0, 0, 0, 0.3);
				}
				.action-context {
					max-height: 300px;
					overflow-y: auto;
				}
				.action-preview {
					max-height: 200px;
				}
			}

			/* Wide desktop */
			@media (min-width: 1400px) {
				.header-content,
				.search-bar,
				.main {
					max-width: 1400px;
				}
				.sessions-grid {
					grid-template-columns: repeat(auto-fill, minmax(420px, 1fr));
				}
				.action-bar {
					width: 450px;
				}
			}

			.action-btn-secondary {
				flex: 1;
				background: var(--bg-elevated);
				border: 1px solid var(--border);
				border-radius: 6px;
				padding: 0.5rem 0.75rem;
				font-family: inherit;
				font-size: 11px;
				color: var(--text-secondary);
				cursor: pointer;
				transition: all 0.15s;
			}
			.action-btn-secondary:hover {
				background: var(--bg-panel);
				color: var(--text-primary);
			}
			.action-btn-secondary.danger {
				color: var(--error);
				border-color: rgba(239, 68, 68, 0.3);
			}
			.action-btn-secondary.danger:hover {
				background: rgba(239, 68, 68, 0.15);
				border-color: var(--error);
			}
		</style>
	</head>
	<body>
		<header class="header">
			<div class="header-content">
				<div class="logo">
					<div class="logo-icon">MC</div>
					<span class="logo-text">mission control</span>
				</div>
				<div class="header-right">
					<div class="status-summary" id="status-summary"></div>
					<button class="notification-btn" id="notificationBtn" onclick="toggleNotifications()" title="Toggle notifications">
						<svg class="bell-off" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
							<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
							<path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
							<line x1="1" y1="1" x2="23" y2="23"></line>
						</svg>
						<svg class="bell-on" style="display:none" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
							<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
							<path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
						</svg>
					</button>
					<button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
						<svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
							<circle cx="12" cy="12" r="5"></circle>
							<line x1="12" y1="1" x2="12" y2="3"></line>
							<line x1="12" y1="21" x2="12" y2="23"></line>
							<line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
							<line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
							<line x1="1" y1="12" x2="3" y2="12"></line>
							<line x1="21" y1="12" x2="23" y2="12"></line>
							<line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
							<line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
						</svg>
						<svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
							<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
						</svg>
					</button>
				</div>
			</div>
			<div class="search-bar">
				<input type="text" class="search-input" id="searchInput" placeholder="Filter sessions..." oninput="filterSessions(this.value)"/>
			</div>
		</header>
		<main class="main">
			<div id="sessions">
				<div class="empty-state">
					<p>Loading...</p>
				</div>
			</div>
		</main>
		<!-- Action bar backdrop -->
		<div class="action-backdrop" id="actionBackdrop" onclick="closeActionBar()"></div>
		<!-- Action bar -->
		<div class="action-bar" id="actionBar">
			<div class="action-bar-content">
				<div class="action-target">
					<span id="actionTarget"></span>
					<button class="action-close" onclick="closeActionBar()">✕</button>
				</div>
				<div class="action-context" id="actionContext">
					<div class="action-status" id="actionStatus"></div>
					<div class="action-preview" id="actionPreview"></div>
				</div>
				<div class="action-choices hidden" id="actionChoices"></div>
				<div class="action-input-row">
					<input type="text" class="action-input" placeholder="Send input..." id="actionInput" autocapitalize="off" autocorrect="off" spellcheck="false"/>
					<button class="action-btn stop" onclick="sendStop()" title="Stop (Escape)">
						<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
						</svg>
					</button>
					<button class="action-btn view" onclick="viewPane()">View</button>
					<button class="action-btn" onclick="sendInput()">Send</button>
				</div>
				<div class="action-extra-row" style="display: flex; gap: 0.375rem; margin-top: 0.5rem;">
					<button class="action-btn-secondary" onclick="respawnPane()" title="Respawn pane">Respawn</button>
					<button class="action-btn-secondary danger" onclick="closePane()" title="Close pane">Close pane</button>
					<button class="action-btn-secondary danger" onclick="closeWindow()" title="Close window">Close window</button>
				</div>
			</div>
		</div>
		<script src="/static/app.js"></script>
		<script>
			// Track expanded sessions
			const expandedSessions = new Set();
			let selectedTarget = null;
			let currentFilter = '';

			// Dismissed sessions (stored in localStorage)
			const DISMISSED_KEY = 'houston-dismissed-sessions';
			let dismissedSessions = new Map(); // session -> timestamp

			function loadDismissed() {
				try {
					const stored = localStorage.getItem(DISMISSED_KEY);
					if (stored) {
						dismissedSessions = new Map(JSON.parse(stored));
					}
				} catch (e) {
					console.warn('Failed to load dismissed sessions:', e);
				}
			}

			function saveDismissed() {
				try {
					localStorage.setItem(DISMISSED_KEY, JSON.stringify([...dismissedSessions]));
				} catch (e) {
					console.warn('Failed to save dismissed sessions:', e);
				}
			}

			function dismissSession(sessionName) {
				dismissedSessions.set(sessionName, Date.now());
				saveDismissed();
				applyDismissals();
			}

			function undismissSession(sessionName) {
				dismissedSessions.delete(sessionName);
				saveDismissed();
			}

			function applyDismissals() {
				// Move dismissed sessions from attention to idle visually
				document.querySelectorAll('.session.has-attention').forEach(session => {
					const name = session.dataset.session;
					if (dismissedSessions.has(name)) {
						session.classList.add('dismissed');
						session.classList.remove('has-attention');
						// Update indicator to idle
						const indicator = session.querySelector('.session-indicator');
						if (indicator) {
							indicator.className = 'session-indicator idle';
						}
						// Hide badge and dismiss button
						const badge = session.querySelector('.session-badge');
						const dismissBtn = session.querySelector('.dismiss-btn');
						if (badge) badge.style.display = 'none';
						if (dismissBtn) dismissBtn.style.display = 'none';
					}
				});

				// Clear dismissals for sessions no longer needing attention
				// (they'll naturally be in idle/active sections)
				const attentionSessions = new Set();
				document.querySelectorAll('.session.has-attention, .session[data-was-attention="true"]').forEach(s => {
					attentionSessions.add(s.dataset.session);
				});
				for (const [name] of dismissedSessions) {
					if (!attentionSessions.has(name)) {
						dismissedSessions.delete(name);
					}
				}
				saveDismissed();
			}

			// Load dismissed on page load
			loadDismissed();

			// Event delegation for dismiss buttons
			document.addEventListener('click', function(e) {
				const dismissBtn = e.target.closest('[data-dismiss-session]');
				if (dismissBtn) {
					e.stopPropagation();
					const sessionName = dismissBtn.dataset.dismissSession;
					dismissSession(sessionName);
				}
			});

			function filterSessions(query) {
				currentFilter = query.toLowerCase().trim();
				const sessions = document.querySelectorAll('#sessions .session');

				sessions.forEach(session => {
					const sessionName = session.dataset.session?.toLowerCase() || '';
					const windows = session.querySelectorAll('.window');
					let hasMatch = false;

					windows.forEach(win => {
						const windowName = (win.dataset.name || '').toLowerCase();
						const matches = !currentFilter ||
							sessionName.includes(currentFilter) ||
							windowName.includes(currentFilter);

						win.style.display = matches ? '' : 'none';
						if (matches) hasMatch = true;
					});

					// Show session if name matches or any window matches
					const sessionMatches = !currentFilter || sessionName.includes(currentFilter) || hasMatch;
					session.style.display = sessionMatches ? '' : 'none';

					// Auto-expand if filtering and has matches
					if (currentFilter && hasMatch) {
						session.classList.add('expanded');
						session.querySelector('.windows')?.classList.remove('hidden');
					}
				});
			}

			function toggleSession(header) {
				const session = header.closest('.session');
				const windows = session.querySelector('.windows');
				const sessionName = session.dataset.session;

				session.classList.toggle('expanded');
				windows.classList.toggle('hidden');

				if (session.classList.contains('expanded')) {
					expandedSessions.add(sessionName);
				} else {
					expandedSessions.delete(sessionName);
				}
			}

			function restoreExpandedState() {
				document.querySelectorAll('.session').forEach(session => {
					const name = session.dataset.session;
					if (expandedSessions.has(name)) {
						session.classList.add('expanded');
						session.querySelector('.windows')?.classList.remove('hidden');
					}
				});
			}

			// Update status summary counts in header
			function updateStatusSummary() {
				const container = document.getElementById('sessions');
				const attention = container.querySelectorAll('.window-indicator.attention').length;
				const error = container.querySelectorAll('.window-indicator.error').length;
				const working = container.querySelectorAll('.window-indicator.working').length;
				const idle = container.querySelectorAll('.window-indicator.idle').length;

				const summary = document.getElementById('status-summary');
				let html = '';
				if (attention + error > 0) {
					html += `<div class="status-count"><div class="status-dot attention"></div><span>${attention + error}</span></div>`;
				}
				if (working > 0) {
					html += `<div class="status-count"><div class="status-dot working"></div><span>${working}</span></div>`;
				}
				if (idle > 0) {
					html += `<div class="status-count"><div class="status-dot idle"></div><span>${idle}</span></div>`;
				}
				summary.innerHTML = html;
			}

			// Action bar functions
			function selectWindow(el) {
				const session = el.dataset.session;
				const windowIdx = parseInt(el.dataset.window);
				const paneIdx = parseInt(el.dataset.pane || '0');
				const windowName = el.dataset.name;
				const status = el.dataset.status;
				const indicator = el.dataset.indicator;
				const preview = el.dataset.preview;
				const question = el.dataset.question;
				const choices = el.dataset.choices;

				selectedTarget = { session, window: windowIdx, pane: paneIdx };
				document.getElementById('actionTarget').textContent = `${session}:${windowIdx} ${windowName}`;

				// Update context area
				const context = document.getElementById('actionContext');
				const statusEl = document.getElementById('actionStatus');
				const previewEl = document.getElementById('actionPreview');

				context.className = 'action-context ' + indicator;
				statusEl.className = 'action-status ' + indicator;
				statusEl.textContent = status;

				// Show choices if available, then preview (don't duplicate question - it's in status)
				let html = '';
				if (choices) {
					const choiceList = choices.split('|');
					choiceList.forEach((choice, i) => {
						html += `<div class="action-preview-line" style="padding-left: 0.5rem;">${i + 1}. ${escapeHtml(choice)}</div>`;
					});
				}
				// Show preview, filtering out lines that match the question/status
				if (preview) {
					if (html) html += '<div style="margin-top: 0.5rem; border-top: 1px solid var(--border); padding-top: 0.5rem;"></div>';
					const previewLines = preview.split('\n').filter(line => {
						// Skip lines that are the same as status/question to avoid duplication
						const trimmed = line.trim();
						if (question && trimmed === question.trim()) return false;
						if (status && trimmed === status.trim()) return false;
						return true;
					});
					html += previewLines.map(line =>
						`<div class="action-preview-line">${escapeHtml(line)}</div>`
					).join('');
				}
				if (!html) {
					html = '<div class="action-preview-line">No output</div>';
				}
				previewEl.innerHTML = html;

				// Show choice buttons if choices available
				const choicesEl = document.getElementById('actionChoices');
				if (choices) {
					const choiceList = choices.split('|');
					let btnHtml = '';
					choiceList.forEach((choice, i) => {
						const shortChoice = choice.length > 25 ? choice.substring(0, 22) + '...' : choice;
						btnHtml += `<button class="choice-btn" onclick="sendChoice(${i + 1})">
							<span class="choice-num">${i + 1}</span>
							${escapeHtml(shortChoice)}
						</button>`;
					});
					choicesEl.innerHTML = btnHtml;
					choicesEl.classList.remove('hidden');
				} else {
					choicesEl.classList.add('hidden');
				}

				document.getElementById('actionBackdrop').classList.add('visible');
				document.getElementById('actionBar').classList.add('visible');
				document.getElementById('actionInput').focus();
			}

			function sendChoice(num) {
				if (!selectedTarget) return;
				fetch(`/pane/${encodeURIComponent(selectedTarget.session)}:${selectedTarget.window}.${selectedTarget.pane}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: `input=${num}&noenter=true`
				});
				closeActionBar();
			}

			function escapeHtml(text) {
				const div = document.createElement('div');
				div.textContent = text;
				return div.innerHTML;
			}

			function closeActionBar() {
				document.getElementById('actionBackdrop').classList.remove('visible');
				document.getElementById('actionBar').classList.remove('visible');
				selectedTarget = null;
			}

			function refreshActionBar() {
				if (!selectedTarget) return;
				// Find the updated window element
				const windowEl = document.querySelector(
					`.window[data-session="${selectedTarget.session}"][data-window="${selectedTarget.window}"]`
				);
				if (windowEl) {
					// Re-trigger selectWindow to refresh the action bar content
					selectWindow(windowEl);
				}
			}

			function sendInput() {
				if (!selectedTarget) return;
				const input = document.getElementById('actionInput');
				const value = input.value;
				if (!value) return;

				fetch(`/pane/${encodeURIComponent(selectedTarget.session)}:${selectedTarget.window}.${selectedTarget.pane}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: `input=${encodeURIComponent(value)}`
				});
				input.value = '';
			}

			function sendStop() {
				if (!selectedTarget) return;
				fetch(`/pane/${encodeURIComponent(selectedTarget.session)}:${selectedTarget.window}.${selectedTarget.pane}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: 'input=Escape&special=true'
				});
			}

			function viewPane() {
				if (!selectedTarget) return;
				window.location.href = `/pane/${encodeURIComponent(selectedTarget.session)}:${selectedTarget.window}.${selectedTarget.pane}`;
			}

			function respawnPane() {
				if (!selectedTarget) return;
				if (!confirm('Respawn this pane? This will kill the current process.')) return;
				fetch(`/pane/${encodeURIComponent(selectedTarget.session)}:${selectedTarget.window}.${selectedTarget.pane}/respawn`, {
					method: 'POST'
				});
				closeActionBar();
			}

			function closePane() {
				if (!selectedTarget) return;
				if (!confirm('Close this pane?')) return;
				fetch(`/pane/${encodeURIComponent(selectedTarget.session)}:${selectedTarget.window}.${selectedTarget.pane}/kill`, {
					method: 'POST'
				});
				closeActionBar();
			}

			function closeWindow() {
				if (!selectedTarget) return;
				if (!confirm('Close entire window? This will close all panes in this window.')) return;
				fetch(`/pane/${encodeURIComponent(selectedTarget.session)}:${selectedTarget.window}.${selectedTarget.pane}/kill-window`, {
					method: 'POST'
				});
				closeActionBar();
			}

			// Close action bar on escape
			document.addEventListener('keydown', (e) => {
				if (e.key === 'Escape') closeActionBar();
				if (e.key === 'Enter' && document.activeElement.id === 'actionInput') {
					e.preventDefault();
					sendInput();
				}
			});

			// Handle SSE manually for flicker-free updates
			function connectSSE() {
				const evtSource = new EventSource('/sessions?stream=1');
				const container = document.getElementById('sessions');

				evtSource.onmessage = function(e) {
					const temp = document.createElement('div');
					temp.innerHTML = e.data;

					temp.querySelectorAll('.session').forEach(session => {
						const name = session.dataset.session;
						// Auto-expand sessions that need attention, or were manually expanded
						if (expandedSessions.has(name) || session.classList.contains('has-attention')) {
							session.classList.add('expanded');
							session.querySelector('.windows')?.classList.remove('hidden');
							expandedSessions.add(name); // Track auto-expanded too
						}
					});

					Idiomorph.morph(container, temp.innerHTML, { morphStyle: 'innerHTML' });
					updateStatusSummary();
					// Apply dismissals after morph
					applyDismissals();
					// Re-apply filter if active
					if (currentFilter) {
						filterSessions(currentFilter);
					}
					// Refresh action bar if open
					refreshActionBar();
				};

				evtSource.onerror = function() {
					console.log('SSE connection lost, reconnecting...');
					evtSource.close();
					setTimeout(connectSSE, 3000);
				};
			}

			connectSSE();

			// Theme support
			function initTheme() {
				const saved = localStorage.getItem('houston-theme');
				if (saved === 'light') {
					document.documentElement.setAttribute('data-theme', 'light');
				} else if (saved === 'dark') {
					document.documentElement.removeAttribute('data-theme');
				} else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
					document.documentElement.setAttribute('data-theme', 'light');
				}
			}
			initTheme();

			function toggleTheme() {
				const isLight = document.documentElement.getAttribute('data-theme') === 'light';
				if (isLight) {
					document.documentElement.removeAttribute('data-theme');
					localStorage.setItem('houston-theme', 'dark');
				} else {
					document.documentElement.setAttribute('data-theme', 'light');
					localStorage.setItem('houston-theme', 'light');
				}
			}

			// Notification support
			let notificationsEnabled = false;
			let notifiedPanes = new Set();

			async function toggleNotifications() {
				const btn = document.getElementById('notificationBtn');

				if (!notificationsEnabled) {
					// Request permission
					if (!('Notification' in window)) {
						alert('Notifications not supported in this browser');
						return;
					}

					const permission = await Notification.requestPermission();
					if (permission === 'granted') {
						// Register service worker
						if ('serviceWorker' in navigator) {
							try {
								await navigator.serviceWorker.register('/static/sw.js');
							} catch (e) {
								console.log('Service worker registration failed:', e);
							}
						}
						notificationsEnabled = true;
						btn.classList.add('enabled');
						btn.querySelector('.bell-off').style.display = 'none';
						btn.querySelector('.bell-on').style.display = 'block';
						btn.title = 'Notifications enabled';
					}
				} else {
					notificationsEnabled = false;
					btn.classList.remove('enabled');
					btn.querySelector('.bell-off').style.display = 'block';
					btn.querySelector('.bell-on').style.display = 'none';
					btn.title = 'Notifications disabled';
					notifiedPanes.clear();
				}
			}

			function checkAndNotify() {
				if (!notificationsEnabled) return;

				const attentionWindows = document.querySelectorAll('.window-indicator.attention');
				attentionWindows.forEach(indicator => {
					const win = indicator.closest('.window');
					if (!win) return;

					const paneKey = `${win.dataset.session}:${win.dataset.window}.${win.dataset.pane}`;
					if (notifiedPanes.has(paneKey)) return;

					notifiedPanes.add(paneKey);

					const title = `${win.dataset.session}:${win.dataset.window}`;
					const body = win.dataset.status || 'Needs attention';

					new Notification(title, {
						body: body,
						icon: '/static/icon.png',
						tag: paneKey,
						data: { url: `/pane/${paneKey}` }
					});
				});

				// Clean up notified panes that no longer need attention
				const currentAttention = new Set();
				attentionWindows.forEach(indicator => {
					const win = indicator.closest('.window');
					if (win) {
						currentAttention.add(`${win.dataset.session}:${win.dataset.window}.${win.dataset.pane}`);
					}
				});
				notifiedPanes = new Set([...notifiedPanes].filter(p => currentAttention.has(p)));
			}

			// Check for attention-needing panes after SSE updates
			const originalMorph = Idiomorph.morph;
			Idiomorph.morph = function(...args) {
				const result = originalMorph.apply(this, args);
				setTimeout(checkAndNotify, 100);
				return result;
			};
		</script>
	</body>
	</html>
}

// Sessions renders the sessions list with window-level detail
templ Sessions(data SessionsData) {
	<div class="sessions-grid">
		// Needs Attention section
		if len(data.NeedsAttention) > 0 {
			<div class="section-label">Needs attention</div>
			for _, sess := range data.NeedsAttention {
				@sessionCardV2(sess, true)
			}
		}
		// Active section
		if len(data.Active) > 0 {
			<div class="section-label">Active</div>
			for _, sess := range data.Active {
				@sessionCardV2(sess, false)
			}
		}
		// Idle section
		if len(data.Idle) > 0 {
			<div class="section-label">Idle</div>
			for _, sess := range data.Idle {
				@sessionCardV2(sess, false)
			}
		}
		// Empty state
		if len(data.NeedsAttention) == 0 && len(data.Active) == 0 && len(data.Idle) == 0 {
			<div class="empty-state">
				<div class="empty-icon">◯</div>
				<p>No tmux sessions</p>
			</div>
		}
	</div>
}

// sessionCardV2 renders a session with its windows
templ sessionCardV2(sess SessionWithWindows, expanded bool) {
	<div class={ "session", templ.KV("has-attention", sess.AttentionCount > 0), templ.KV("expanded", expanded) } data-session={ sess.Session.Name }>
		<div class="session-header" onclick="toggleSession(this)">
			<div class={ "session-indicator", getSessionIndicator(sess) }></div>
			<div class="session-info">
				<div class="session-name">{ sess.Session.Name }</div>
				<div class="session-meta">{ fmt.Sprintf("%d windows", len(sess.Windows)) }</div>
			</div>
			if sess.AttentionCount > 0 {
				<span class="session-badge">{ fmt.Sprintf("%d", sess.AttentionCount) }</span>
				<button class="dismiss-btn" data-dismiss-session={ sess.Session.Name } title="Dismiss">✕</button>
			}
			<svg class="session-chevron" width="20" height="20" viewBox="0 0 20 20" fill="none">
				<path d="M5 7.5L10 12.5L15 7.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path>
			</svg>
		</div>
		<div class={ "windows", templ.KV("hidden", !expanded) }>
			for _, win := range sess.Windows {
				@windowCard(sess.Session.Name, win)
			}
		</div>
	</div>
}

// windowCard renders a single window within a session
templ windowCard(sessionName string, win WindowWithStatus) {
	<div
		data-session={ sessionName }
		data-window={ fmt.Sprintf("%d", win.Window.Index) }
		data-pane={ fmt.Sprintf("%d", win.Pane.Index) }
		data-name={ win.Window.Name }
		data-status={ getWindowStatusText(win) }
		data-indicator={ getWindowIndicator(win) }
		data-preview={ strings.Join(win.Preview, "\n") }
		data-question={ win.ParseResult.Question }
		data-choices={ strings.Join(win.ParseResult.Choices, "|") }
		onclick="selectWindow(this)"
		class={ "window", templ.KV("attention", win.NeedsAttention) }
	>
		<div class={ "window-indicator", getWindowIndicator(win) }></div>
		<div class="window-info">
			<div class="window-name">{ fmt.Sprintf("%d: %s", win.Window.Index, getWindowDisplayName(win)) }</div>
			<div class={ "window-status", getWindowIndicator(win) }>
				{ getWindowStatusText(win) }
			</div>
			if len(win.Preview) > 0 {
				<div class="window-preview">
					for _, line := range win.Preview {
						<div class="preview-line">{ line }</div>
					}
				</div>
			}
		</div>
		<div class="window-actions">
			<a href={ templ.SafeURL(fmt.Sprintf("/pane/%s:%d.%d", sessionName, win.Window.Index, win.Pane.Index)) }
				class="window-view-btn"
				onclick="event.stopPropagation()"
				title="Open pane view">view</a>
			<span class="window-arrow">→</span>
		</div>
	</div>
}

// Helper functions for template
func getSessionIndicator(sess SessionWithWindows) string {
	if sess.AttentionCount > 0 {
		return "attention"
	}
	if sess.HasWorking {
		return "working"
	}
	return "idle"
}

func getWindowIndicator(win WindowWithStatus) string {
	if win.NeedsAttention {
		return "attention"
	}
	if win.ParseResult.Type == parser.TypeWorking {
		return "working"
	}
	return "idle"
}

func getWindowStatusText(win WindowWithStatus) string {
	switch win.ParseResult.Type {
	case parser.TypeError:
		// Show error snippet if available, otherwise just indicate there was an error
		if win.ParseResult.ErrorSnippet != "" {
			snippet := win.ParseResult.ErrorSnippet
			if len(snippet) > 50 {
				snippet = snippet[:47] + "..."
			}
			return snippet
		}
		return ""
	case parser.TypeChoice:
		return "Waiting for choice..."
	case parser.TypeQuestion:
		if win.ParseResult.Question != "" {
			q := win.ParseResult.Question
			if len(q) > 40 {
				q = q[:37] + "..."
			}
			return q
		}
		return "Waiting for input..."
	case parser.TypeWorking:
		if win.ParseResult.Activity != "" {
			return win.ParseResult.Activity + "..."
		}
		return "Working..."
	default:
		return "Idle"
	}
}

// getWindowDisplayName returns the display name for a window
// Now window_name contains the branch (set by tmux_nerd)
func getWindowDisplayName(win WindowWithStatus) string {
	// Window.Name now contains the branch name
	return win.Window.Name
}

// getPaneDisplayName returns the display name for a pane
// Uses title if set (supports nerd fonts), falls back to index + command
func getPaneDisplayName(p tmux.PaneInfo) string {
	if p.Title != "" && p.Title != p.Command {
		return p.Title
	}
	return fmt.Sprintf("P%d", p.Index)
}

// getPaneSubtitle returns the subtitle for a pane (command if title is used)
func getPaneSubtitle(p tmux.PaneInfo) string {
	if p.Title != "" && p.Title != p.Command {
		return p.Command
	}
	return p.Command
}

// PanePage renders the pane view
templ PanePage(data PaneData) {
	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
		<title>{ data.Pane.Session } - houston</title>
		<!-- Nerd Font for terminal icons -->
		<link href="https://cdn.jsdelivr.net/gh/mshaugh/nerdfont-webfonts@v3.3.0/build/symbols-nerd-font-mono.css" rel="stylesheet"/>
		<script src="https://unpkg.com/htmx.org@1.9.10"></script>
		<script src="https://unpkg.com/htmx.org@1.9.10/dist/ext/sse.js"></script>
		<style>
			:root {
				--bg-deep: #0a0a0f;
				--bg-panel: #12121a;
				--bg-elevated: #1a1a24;
				--border: #2a2a3a;
				--text-primary: #e8e8f0;
				--text-secondary: #8888a0;
				--text-dim: #555566;
				--accent: #00d4aa;
				--accent-dim: rgba(0, 212, 170, 0.15);
				--attention: #f97316;
				--error: #ef4444;
				--working: #3b82f6;
				--idle: #6b7280;
			}
			[data-theme="light"] {
				--bg-deep: #f4f4f5;
				--bg-panel: #ffffff;
				--bg-elevated: #e4e4e7;
				--border: #d4d4d8;
				--text-primary: #18181b;
				--text-secondary: #52525b;
				--text-dim: #a1a1aa;
				--accent: #0891b2;
				--accent-dim: rgba(8, 145, 178, 0.12);
				--attention: #ea580c;
				--error: #dc2626;
				--working: #2563eb;
				--idle: #a1a1aa;
			}
			* { box-sizing: border-box; margin: 0; padding: 0; }
			body {
				font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', system-ui, sans-serif;
				background: var(--bg-deep);
				color: var(--text-primary);
				min-height: 100vh;
				min-height: 100dvh;
			}
			.terminal {
				font-family: ui-monospace, 'SF Mono', 'Symbols Nerd Font Mono', monospace;
				font-size: 12px;
				line-height: 1.5;
				-webkit-user-select: text;
				user-select: text;
				cursor: text;
				/* Enable all fancy font features */
				font-variant-ligatures: common-ligatures contextual;
				font-feature-settings: "liga" 1, "calt" 1;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
				text-rendering: optimizeLegibility;
			}
			.diff-add { background-color: rgba(34, 197, 94, 0.25); }
			.diff-del { background-color: rgba(239, 68, 68, 0.25); }
			.diff-hunk { background-color: rgba(59, 130, 246, 0.25); }
			.user-input { background-color: rgba(59, 130, 246, 0.08); }
			.header {
				background: var(--bg-panel);
				border-bottom: 1px solid var(--border);
				padding: 0.75rem 1rem;
				padding-left: calc(1rem + env(safe-area-inset-left));
				padding-right: calc(1rem + env(safe-area-inset-right));
				display: flex;
				align-items: center;
				gap: 0.75rem;
			}
			.back-btn {
				background: none;
				border: none;
				color: var(--text-secondary);
				padding: 0.5rem;
				margin: -0.5rem;
				cursor: pointer;
				border-radius: 6px;
			}
			.back-btn:hover { background: var(--bg-elevated); color: var(--text-primary); }
			.header-title {
				flex: 1;
				font-weight: 500;
				font-size: 15px;
				color: var(--text-primary);
			}
			.header-target {
				font-size: 12px;
				color: var(--text-secondary);
				font-family: 'SF Mono', ui-monospace, monospace;
			}
			.window-dropdown {
				background: var(--bg-elevated);
				color: var(--text-primary);
				border: 1.5px solid var(--border);
				border-radius: 6px;
				padding: 0.375rem 0.75rem;
				font-size: 13px;
				font-family: 'SF Mono', 'Symbols Nerd Font Mono', ui-monospace, monospace;
				cursor: pointer;
				max-width: 250px;
				font-weight: 500;
			}
			.window-dropdown:hover {
				border-color: var(--accent);
				background: var(--bg-panel);
			}
			.window-dropdown:focus {
				outline: 2px solid var(--accent);
				outline-offset: 1px;
			}
			.header-window {
				font-size: 13px;
				color: var(--text-secondary);
				font-family: 'SF Mono', 'Symbols Nerd Font Mono', ui-monospace, monospace;
			}
			.menu-btn {
				background: none;
				border: none;
				color: var(--text-secondary);
				padding: 0.5rem;
				cursor: pointer;
				border-radius: 6px;
			}
			.menu-btn:hover { background: var(--bg-elevated); color: var(--text-primary); }
			.menu {
				position: absolute;
				right: 0;
				top: 100%;
				margin-top: 0.5rem;
				background: var(--bg-elevated);
				border: 1px solid var(--border);
				border-radius: 8px;
				min-width: 160px;
				z-index: 100;
				box-shadow: 0 4px 12px rgba(0,0,0,0.4);
			}
			.menu.hidden { display: none; }
			.menu button {
				width: 100%;
				text-align: left;
				padding: 0.625rem 1rem;
				background: none;
				border: none;
				color: var(--text-primary);
				font-size: 13px;
				cursor: pointer;
			}
			.menu button:hover { background: var(--bg-panel); }
			.selector {
				display: flex;
				gap: 0.5rem;
				padding: 0.5rem 0.75rem;
				padding-left: calc(0.75rem + env(safe-area-inset-left));
				padding-right: calc(0.75rem + env(safe-area-inset-right));
				background: var(--bg-panel);
				border-bottom: 1px solid var(--border);
				overflow-x: auto;
				-webkit-overflow-scrolling: touch;
			}
			.selector::-webkit-scrollbar { display: none; }
			.selector-item {
				padding: 0.375rem 0.75rem;
				border-radius: 6px;
				font-size: 12px;
				font-family: 'SF Mono', 'Symbols Nerd Font Mono', ui-monospace, monospace;
				white-space: nowrap;
				text-decoration: none;
				background: var(--bg-elevated);
				color: var(--text-secondary);
				border: 1px solid transparent;
				transition: all 0.15s;
			}
			.selector-item:hover { color: var(--text-primary); border-color: var(--border); }
			.selector-item.active {
				background: var(--accent-dim);
				color: var(--accent);
				border-color: var(--accent);
			}
			.selector-item.pane-active {
				background: rgba(59, 130, 246, 0.15);
				color: var(--working);
				border-color: var(--working);
			}
			.selector-sep {
				color: var(--text-dim);
				padding: 0 0.25rem;
				align-self: center;
			}
			.output-container {
				flex: 1;
				overflow: auto;
				background: var(--bg-deep);
				-webkit-overflow-scrolling: touch;
				/* Force GPU acceleration for smooth scrolling */
				transform: translateZ(0);
				will-change: scroll-position;
			}
			.output {
				padding: 1rem;
				color: var(--text-primary);
				white-space: pre;
				min-width: 100%;
				/* Force browser to calculate full layout upfront */
				content-visibility: visible;
			}
			.choices-bar {
				display: flex;
				gap: 0.5rem;
				padding: 0.75rem;
				background: var(--bg-panel);
				border-top: 1px solid var(--border);
			}
			.choices-bar.hidden {
				display: none;
			}
			.choice-btn {
				flex: 1;
				padding: 0.625rem 0.5rem;
				background: var(--bg-elevated);
				border: 1px solid var(--border);
				border-radius: 6px;
				color: var(--text-primary);
				font-size: 12px;
				cursor: pointer;
				text-align: center;
				line-height: 1.3;
				transition: all 0.15s;
			}
			.choice-btn:hover {
				background: var(--accent-dim);
				border-color: var(--accent);
			}
			.choice-num {
				display: block;
				font-size: 14px;
				font-weight: 600;
				color: var(--accent);
				margin-bottom: 2px;
			}
			.choice-text {
				display: block;
				font-size: 11px;
				color: var(--text-secondary);
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}
			.pending-input-bar {
				display: flex;
				align-items: center;
				gap: 0.5rem;
				padding: 0.5rem 0.75rem;
				background: var(--bg-elevated);
				border-top: 1px solid var(--border);
				border-bottom: 1px solid var(--border);
				font-size: 12px;
			}
			.pending-input-bar.hidden { display: none; }
			.pending-label {
				color: var(--text-dim);
				flex-shrink: 0;
			}
			.pending-text {
				flex: 1;
				color: var(--text-primary);
				font-family: 'SF Mono', 'Symbols Nerd Font Mono', ui-monospace, monospace;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				background: var(--bg-deep);
				padding: 0.25rem 0.5rem;
				border-radius: 4px;
				border: 1px solid var(--border);
			}
			.status-section {
				background: var(--bg-panel);
				border-top: 1px solid var(--border);
				border-bottom: 1px solid var(--border);
				padding: 0;
				max-height: 0;
				overflow: hidden;
				transition: max-height 0.2s ease-out, padding 0.2s ease-out;
			}
			.status-section.visible {
				max-height: 80px;
				padding: 0.5rem 1rem;
			}
			.status-line-container {
				display: flex;
				justify-content: space-between;
				align-items: center;
				width: 100%;
				font-family: 'IBM Plex Mono', monospace;
				font-size: 11px;
				color: var(--text-secondary);
				gap: 1rem;
			}
			.status-line-left {
				white-space: pre;
				flex-shrink: 0;
			}
			.status-line-right {
				white-space: pre;
				flex-shrink: 0;
				margin-left: auto;
			}
			.mode-pill {
				padding: 0.125rem 0.5rem;
				border-radius: 3px;
				font-size: 9px;
				font-weight: 600;
				letter-spacing: 0.02em;
				text-transform: uppercase;
				border: none;
				cursor: pointer;
				transition: opacity 0.15s;
			}
			.mode-pill:hover { opacity: 0.8; }
			.mode-pill.hidden { display: none; }
			.mode-pill.insert { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
			.mode-pill.accept { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
			.mode-pill.plan { background: rgba(168, 85, 247, 0.2); color: #a855f7; }
			.status-toggle-btn {
				background: none;
				border: 1px solid var(--border);
				color: var(--text-secondary);
				cursor: pointer;
				padding: 0.25rem 0.5rem;
				border-radius: 4px;
				font-size: 10px;
				margin-left: auto;
			}
			.status-toggle-btn:hover {
				background: var(--bg-elevated);
			}
			.pending-edit-btn, .pending-clear-btn {
				padding: 0.25rem 0.625rem;
				border-radius: 4px;
				font-size: 11px;
				font-weight: 500;
				cursor: pointer;
				transition: all 0.15s;
				border: 1px solid var(--border);
			}
			.pending-edit-btn {
				background: var(--accent-dim);
				color: var(--accent);
				border-color: var(--accent);
			}
			.pending-edit-btn:hover {
				background: var(--accent);
				color: var(--bg-deep);
			}
			.pending-clear-btn {
				background: var(--bg-panel);
				color: var(--text-secondary);
			}
			.pending-clear-btn:hover {
				background: rgba(239, 68, 68, 0.15);
				color: var(--error);
				border-color: var(--error);
			}
			.input-bar {
				position: fixed;
				bottom: 0;
				left: env(safe-area-inset-left);
				right: env(safe-area-inset-right);
				display: flex;
				gap: 0.5rem;
				padding: 0.75rem;
				padding-bottom: calc(0.75rem + env(safe-area-inset-bottom));
				background: var(--bg-panel);
				border-top: 1px solid var(--border);
				align-items: center;
				z-index: 100;
			}
			/* Spacer to prevent content from being hidden behind fixed input bar */
			.input-bar-spacer {
				height: calc(3.5rem + env(safe-area-inset-bottom));
				flex-shrink: 0;
			}
			.mode-badge {
				font-size: 10px;
				font-weight: 600;
				padding: 0.25rem 0.5rem;
				border-radius: 4px;
				font-family: 'SF Mono', ui-monospace, monospace;
			}
			.mode-badge.insert { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
			.mode-badge.normal { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
			.autoaccept-toggle {
				display: flex;
				align-items: center;
				gap: 0.25rem;
				padding: 0.25rem 0.5rem;
				border-radius: 4px;
				font-size: 11px;
				font-weight: 500;
				background: var(--bg-elevated);
				border: 1px solid var(--border);
				color: var(--text-dim);
				cursor: pointer;
				transition: all 0.15s;
				flex-shrink: 0;
			}
			.autoaccept-toggle:hover {
				background: var(--bg-panel);
				border-color: var(--text-dim);
			}
			.autoaccept-toggle.on {
				background: rgba(34, 197, 94, 0.15);
				border-color: #22c55e;
				color: #22c55e;
			}
			.autoaccept-toggle.off {
				background: rgba(239, 68, 68, 0.1);
				border-color: var(--border);
				color: var(--text-secondary);
			}
			.autoaccept-icon { font-size: 10px; }
			.autoaccept-state { font-size: 10px; text-transform: uppercase; }
			.input-field {
				flex: 1;
				background: var(--bg-deep);
				border: 1px solid var(--border);
				border-radius: 6px;
				padding: 0.625rem 0.875rem;
				font-family: inherit;
				font-size: 16px; /* Prevents iOS zoom on focus */
				color: var(--text-primary);
				resize: none;
				outline: none;
			}
			.input-field:focus {
				border-color: var(--accent);
				box-shadow: 0 0 0 2px var(--accent-dim);
			}
			.input-field::placeholder { color: var(--text-dim); }
			.action-btn {
				padding: 0.5rem;
				border: none;
				border-radius: 6px;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.action-btn.stop { background: var(--error); color: white; }
			.action-btn.stop:hover { opacity: 0.9; }
			.action-btn.send { background: var(--accent); color: var(--bg-deep); }
			.action-btn.send:hover { opacity: 0.9; }

			/* Pane layout container */
			.pane-layout {
				display: flex;
				flex-direction: column;
				height: 100vh;
				height: 100dvh;
				max-width: 32rem;
				margin: 0 auto;
			}

			/* ============================================
			   PANE PAGE DESKTOP RESPONSIVE STYLES
			   ============================================ */

			/* Tablet breakpoint */
			@media (min-width: 768px) {
				.pane-layout {
					max-width: 900px;
				}
				.terminal {
					font-size: 13px;
				}
				.output {
					padding: 1.5rem;
				}
				.header {
					padding: 1rem 1.5rem;
				}
				.selector {
					padding: 0.75rem 1.5rem;
					gap: 0.75rem;
				}
				.selector-item {
					padding: 0.5rem 1rem;
					font-size: 13px;
				}
				.input-bar {
					padding: 1rem 1.5rem;
					gap: 0.75rem;
				}
				.input-field {
					font-size: 14px;
					padding: 0.75rem 1rem;
				}
				.choices-bar {
					padding: 1rem 1.5rem;
					gap: 0.75rem;
				}
				.choice-btn {
					padding: 0.75rem;
				}
			}

			/* Desktop breakpoint */
			@media (min-width: 1024px) {
				.pane-layout {
					max-width: 1100px;
					margin: 0 auto;
					height: 100vh;
					height: 100dvh;
					display: flex;
					flex-direction: column;
				}
				.terminal {
					font-size: 14px;
					line-height: 1.6;
				}
				.output {
					padding: 2rem;
				}
				.header {
					padding: 1rem 2rem;
				}
				.selector {
					padding: 1rem 2rem;
					flex-wrap: wrap;
				}
				.input-bar {
					padding: 1rem 2rem;
					border-top: 1px solid var(--border);
					border-radius: 0;
				}
				.input-bar-spacer {
					display: none;
				}
				.menu {
					min-width: 200px;
				}
			}

			/* Wide desktop */
			@media (min-width: 1400px) {
				.pane-layout {
					max-width: 1400px;
				}
				.terminal {
					font-size: 14px;
				}
				.output {
					padding: 2rem 3rem;
				}
			}
		</style>
	</head>
	<body>
		<div class="pane-layout">
			<!-- Header -->
			<header class="header">
				<a href="/" class="back-btn">
					<svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
					</svg>
				</a>
				<div class="header-title">{ data.Pane.Session }</div>
				if len(data.Windows) > 1 {
					<select class="window-dropdown" onchange="window.location.href=this.value">
						for _, w := range data.Windows {
							<option
								value={ templ.SafeURL("/pane/" + urlEncode(data.Pane.Session) + ":" + fmt.Sprintf("%d", w.Index)) }
								selected?={ w.Index == data.Pane.Window }
							>
								{ fmt.Sprintf("%d: %s", w.Index, w.Branch) }
							</option>
						}
					</select>
				} else if len(data.Windows) == 1 {
					<div class="header-window">{ fmt.Sprintf("%d: %s", data.Windows[0].Index, data.Windows[0].Branch) }</div>
				}
				<div class="header-target">{ fmt.Sprintf(":%d.%d", data.Pane.Window, data.Pane.Index) }</div>
				<div style="position: relative;">
					<button class="menu-btn" onclick="toggleMenu()">
						<svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"></path>
						</svg>
					</button>
					<div id="menu" class="menu hidden">
						<button
							hx-post={ "/pane/" + data.Pane.URLTarget() + "/send" }
							hx-vals='{"input": "C-c", "special": "true"}'
						>Send Ctrl+C</button>
						<button onclick="scrollToTop()">Scroll to top</button>
						<button
							hx-get={ "/pane/" + data.Pane.URLTarget() }
							hx-target="#output"
							hx-swap="innerHTML"
						>Refresh</button>
						<button
							hx-post={ "/pane/" + data.Pane.URLTarget() + "/respawn" }
							hx-swap="none"
							hx-confirm="Respawn this pane? This will kill the current process."
						>Respawn pane</button>
						<button
							hx-post={ "/pane/" + data.Pane.URLTarget() + "/kill" }
							hx-confirm="Close this pane?"
							style="color: var(--error);"
						>Close pane</button>
						<button
							hx-post={ "/pane/" + data.Pane.URLTarget() + "/kill-window" }
							hx-confirm="Close entire window? This will close all panes in this window."
							style="color: var(--error);"
						>Close window</button>
					</div>
				</div>
			</header>
			<!-- Pane selector -->
			if len(data.Panes) > 0 {
				<div class="selector">
					for _, p := range data.Panes {
						<a
							href={ templ.SafeURL("/pane/" + urlEncode(data.Pane.Session) + ":" + fmt.Sprintf("%d.%d", data.Pane.Window, p.Index)) }
							class={ "selector-item", templ.KV("pane-active", p.Index == data.Pane.Index) }
						>
							{ getPaneDisplayName(p) }
							<span style="font-size: 10px; opacity: 0.7; margin-left: 4px;">{ getPaneSubtitle(p) }</span>
						</a>
					}
				</div>
			}
			<!-- Output area -->
			<div
				id="output-container"
				class="output-container"
				data-pane-target={ data.Pane.URLTarget() }
				hx-ext="sse"
				sse-connect={ "/pane/" + data.Pane.URLTarget() + "?stream=1" }
				sse-swap="message"
				hx-target="#output"
				hx-swap="none"
				onclick="handleOutputClick(event)"
			>
				<pre id="output" class="terminal output">{ data.Output }</pre>
			</div>
			<!-- Claude Status Section (collapsible) -->
			<div id="status-section" class="status-section">
				<div style="display: flex; align-items: center; gap: 0.5rem; justify-content: space-between;">
					<div class="status-line-container">
						<div id="status-line-left" class="status-line-left"></div>
						<div id="status-line-right" class="status-line-right"></div>
					</div>
					<button
						type="button"
						class="status-toggle-btn"
						onclick="toggleStatusSection()"
						title="Toggle status"
					>
						Hide
					</button>
				</div>
			</div>
			<!-- Prompt input indicator (shown when Claude has pending input) -->
			<div id="pending-input-bar" class="pending-input-bar hidden">
				<span class="pending-label">Pending input:</span>
				<span id="pending-input-text" class="pending-text"></span>
				<button class="pending-edit-btn" onclick="editPendingInput()">Edit</button>
				<button class="pending-clear-btn" onclick="clearPendingInput()">Clear</button>
			</div>
			<!-- Quick choice buttons (dynamically updated via SSE) -->
			<div id="choices-bar" class={ "choices-bar", templ.KV("hidden", len(data.ParseResult.Choices) == 0) } data-pane-target={ data.Pane.URLTarget() }>
				for i, choice := range data.ParseResult.Choices {
					<button
						class="choice-btn"
						data-choice={ fmt.Sprintf("%d", i+1) }
						data-choice-text={ choice }
						onclick="sendChoice(this.dataset.choice, this.dataset.choiceText)"
					>
						<span class="choice-num">{ fmt.Sprintf("%d", i+1) }</span>
						<span class="choice-text">{ truncate(choice, 20) }</span>
					</button>
				}
			</div>
			<!-- Spacer for fixed input bar -->
			<div class="input-bar-spacer"></div>
			<!-- Input bar -->
			<form
				id="input-form"
				class="input-bar"
				hx-post={ "/pane/" + data.Pane.URLTarget() + "/send" }
				hx-swap="none"
				hx-on::after-request="this.reset(); document.getElementById('input-field').style.height = 'auto';"
			>
				if data.ParseResult.Mode.String() == "insert" {
					<span id="mode-indicator" class="mode-badge insert">INS</span>
				} else {
					<span id="mode-indicator" class="mode-badge normal">NOR</span>
				}
				<!-- Auto-accept edits toggle -->
				<button
					type="button"
					id="autoaccept-toggle"
					class="autoaccept-toggle"
					onclick="toggleAutoAccept()"
					title="Toggle auto-accept edits (Shift+Tab)"
				>
					<span class="autoaccept-icon">⏵⏵</span>
					<span id="autoaccept-state" class="autoaccept-state">--</span>
				</button>
				<!-- Mode pills -->
				<button
					type="button"
					id="accept-indicator"
					class="mode-pill accept hidden"
					onclick="cycleClaudeMode()"
					title="Click to cycle Claude modes (Shift+Tab)"
				>ACCEPT</button>
				<button
					type="button"
					id="plan-indicator"
					class="mode-pill plan hidden"
					onclick="cycleClaudeMode()"
					title="Click to cycle Claude modes (Shift+Tab)"
				>PLAN</button>
				<textarea
					id="input-field"
					name="input"
					class="input-field"
					placeholder="Send input..."
					autocomplete="off"
					autocapitalize="off"
					autocorrect="off"
					spellcheck="false"
					rows="1"
					onkeydown="handleInputKeydown(event)"
					oninput="autoResize(this)"
				></textarea>
				<!-- Stop button -->
				<button
					type="button"
					class="action-btn stop"
					hx-post={ "/pane/" + data.Pane.URLTarget() + "/send" }
					hx-vals='{"input": "Escape", "special": "true"}'
					hx-swap="none"
					title="Stop (Escape)"
				>
					<svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
					</svg>
				</button>
				<!-- Send button -->
				<button type="submit" class="action-btn send" title="Send">
					<svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"></path>
					</svg>
				</button>
			</form>
		</div>
		@paneScripts()
	</body>
	</html>
}

// paneScripts contains the JavaScript for the pane page
templ paneScripts() {
	<script>
		// Theme support - must run synchronously before render
		(function() {
			const saved = localStorage.getItem('houston-theme');
			if (saved === 'light') {
				document.documentElement.setAttribute('data-theme', 'light');
			} else if (!saved && window.matchMedia('(prefers-color-scheme: light)').matches) {
				document.documentElement.setAttribute('data-theme', 'light');
			}
		})();
	</script>
	<script type="module">
		import { AnsiUp } from 'https://cdn.jsdelivr.net/npm/ansi_up@6/ansi_up.js';

		const ansiUp = new AnsiUp();
		ansiUp.escapeHtml = true;  // Ensure HTML is escaped (v6 uses camelCase)

		// Strip ANSI background colors from ansi_up output
		// Only target rgb() values (ansi_up uses rgb, not rgba) to avoid stripping CSS code in terminal content
		function fixBackgrounds(html) {
			html = html.replace(/background-color:\s*rgb\([^)]+\);?/gi, '');
			return html;
		}

		// Add subtle backgrounds for diff lines
		// Claude Code format: "703 +  code" or "703 -  code" (line number, space, +/-, space, code)
		function enhanceDiffs(html) {
			const lines = html.split('\n');
			return lines.map(line => {
				const stripped = line.replace(/<[^>]*>/g, ''); // Strip HTML tags to check content
				// Match Claude Code diff format: line_number +/- code
				const match = stripped.match(/^\s*\d+\s+([-+])\s/);
				if (match) {
					if (match[1] === '+') {
						return '<span class="diff-add">' + line + '</span>';
					} else {
						return '<span class="diff-del">' + line + '</span>';
					}
				}
				// Also match standard diff format (starts with +/- directly)
				if (stripped.startsWith('+') && !stripped.startsWith('+++')) {
					return '<span class="diff-add">' + line + '</span>';
				} else if (stripped.startsWith('-') && !stripped.startsWith('---')) {
					return '<span class="diff-del">' + line + '</span>';
				} else if (stripped.startsWith('@@')) {
					return '<span class="diff-hunk">' + line + '</span>';
				}
				return line;
			}).join('\n');
		}

		// Highlight user input lines with subtle background
		function highlightUserInput(html) {
			const lines = html.split('\n');
			let inUserInput = false;
			return lines.map(line => {
				const stripped = line.replace(/<[^>]*>/g, ''); // Strip HTML tags to check content
				const trimmed = stripped.trim();

				// Check if this is a prompt line (starts with >)
				if (/^\s*>/.test(stripped)) {
					inUserInput = true;
					return '<span class="user-input">' + line + '</span>';
				}

				// Check if this is a horizontal separator (ends user input block)
				if (/^[\s─]{20,}$/.test(stripped)) {
					inUserInput = false;
					return line;
				}

				// Check if this is an indented continuation of user input
				// (starts with spaces and we're in user input mode)
				if (inUserInput && /^\s{2,}/.test(stripped) && trimmed.length > 0) {
					return '<span class="user-input">' + line + '</span>';
				}

				// Empty line might continue user input block
				if (inUserInput && trimmed.length === 0) {
					return line;
				}

				// Any non-indented content ends user input block
				if (trimmed.length > 0 && !/^\s{2,}/.test(stripped)) {
					inUserInput = false;
				}

				return line;
			}).join('\n');
		}

		function processOutput(text) {
			try {
				// Normalize line endings and remove carriage returns
				text = text.replace(/\r\n/g, '\n').replace(/\r/g, '');
				let html = ansiUp.ansi_to_html(text);
				html = fixBackgrounds(html);
				html = enhanceDiffs(html);
				html = highlightUserInput(html);
				return html;
			} catch (err) {
				console.error('ansi_up error:', err);
				// Fallback: escape HTML and preserve newlines
				return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
			}
		}

		document.addEventListener('DOMContentLoaded', function() {
			const container = document.getElementById('output-container');
			if (container) {
				container.scrollTop = container.scrollHeight;
			}
			const output = document.getElementById('output');
			if (output) {
				const text = output.textContent;
				output.innerHTML = processOutput(text);
				// Check for pending input on initial load
				updatePendingInput(text);
			}
		});

		// Handle SSE messages manually to prevent htmx from setting innerHTML directly
		// This prevents terminal content with HTML-like text from being rendered as actual HTML
		document.body.addEventListener('htmx:sseMessage', function(e) {
			console.debug('SSE message received', e.detail.data?.length || 0, 'bytes');
			const output = document.getElementById('output');
			if (!output) return;

			const container = document.getElementById('output-container');
			// Check if user is at the bottom before updating (with 50px threshold)
			const wasAtBottom = container &&
				(container.scrollTop + container.clientHeight >= container.scrollHeight - 50);

			// Get the raw text from SSE (already safe as plain text)
			let text = e.detail.data;

			// Track current mode and Claude mode for status indicators
			let currentMode = '';
			let claudeModeData = {};

			// Extract mode from special first line if present
			const modeMatch = text.match(/^__MODE__:(\w*)\n/);
			if (modeMatch) {
				currentMode = modeMatch[1];
				text = text.substring(modeMatch[0].length);
				updateModeIndicatorDirect(currentMode);
			}

			// Extract choices from special line if present
			const choicesMatch = text.match(/^__CHOICES__:([^\n]*)\n/);
			if (choicesMatch) {
				const choicesStr = choicesMatch[1];
				text = text.substring(choicesMatch[0].length);
				updateChoices(choicesStr ? choicesStr.split('|') : []);
			}

			// Extract Claude mode state if present (JSON)
			const claudeModeMatch = text.match(/^__CLAUDEMODE__:([^\n]*)\n/);
			if (claudeModeMatch) {
				text = text.substring(claudeModeMatch[0].length);
				try {
					claudeModeData = JSON.parse(claudeModeMatch[1] || '{}');
					updateClaudeMode(claudeModeData);
				} catch (e) {
					console.warn('Failed to parse Claude mode:', e);
				}
			}

			// Extract status line with ANSI colors
			const statusLineMatch = text.match(/^__STATUSLINE__:([^\n]*)\n/);
			if (statusLineMatch) {
				text = text.substring(statusLineMatch[0].length);
				updateStatusLine(statusLineMatch[1]);
			}

			// Update mode indicators (combines mode + claudeMode state)
			updateModeIndicators(currentMode, claudeModeData);

			// Process with ansi_up (which has escapeHtml enabled)
			output.innerHTML = processOutput(text);

			// Update pending input bar
			updatePendingInput(text);

			// Only auto-scroll if user was already at the bottom
			if (wasAtBottom && container) {
				container.scrollTop = container.scrollHeight;
			}
		});

		// Update choices bar dynamically
		function updateChoices(choices) {
			const bar = document.getElementById('choices-bar');
			if (!bar) return;

			if (!choices || choices.length === 0 || (choices.length === 1 && choices[0] === '')) {
				bar.classList.add('hidden');
				bar.innerHTML = '';
				return;
			}

			bar.classList.remove('hidden');
			let html = '';
			choices.forEach((choice, i) => {
				const num = i + 1;
				const shortChoice = choice.length > 20 ? choice.substring(0, 17) + '...' : choice;
				html += `<button class="choice-btn" data-choice="${num}" data-choice-text="${escapeHtml(choice)}" onclick="sendChoice('${num}', '${escapeHtml(choice)}')">
					<span class="choice-num">${num}</span>
					<span class="choice-text">${escapeHtml(shortChoice)}</span>
				</button>`;
			});
			bar.innerHTML = html;
		}

		function escapeHtml(text) {
			const div = document.createElement('div');
			div.textContent = text;
			return div.innerHTML;
		}

		// Send choice to pane
		window.sendChoice = function(num, choiceText) {
			const bar = document.getElementById('choices-bar');
			if (!bar) return;
			const target = bar.dataset.paneTarget;
			if (!target) return;
			fetch(`/pane/${target}/send`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: `input=${num}&noenter=true`
			});

			// If choice says "Type here" or similar, focus input for custom response
			if (choiceText && choiceText.toLowerCase().includes('type')) {
				setTimeout(() => {
					const inputField = document.getElementById('input-field');
					if (inputField) {
						inputField.focus();
					}
				}, 100);
			}
		}

		// Log SSE connection events
		document.body.addEventListener('htmx:sseOpen', function(e) {
			console.log('SSE connected');
		});

		document.body.addEventListener('htmx:sseError', function(e) {
			console.warn('SSE error', e.detail);
		});

		// Update mode indicator based on mode string from server
		function updateModeIndicatorDirect(mode) {
			const modeEl = document.getElementById('mode-indicator');
			if (!modeEl) return;

			if (mode === 'insert') {
				modeEl.textContent = 'INS';
				modeEl.className = 'text-xs px-2 py-1 bg-green-600 text-white rounded font-medium shadow-sm';
			} else {
				modeEl.textContent = 'NOR';
				modeEl.className = 'text-xs px-2 py-1 bg-blue-600 text-white rounded font-medium shadow-sm';
			}
		}

		// Fallback: Update mode indicator by parsing text (for initial page load)
		function updateModeIndicator(text) {
			const modeEl = document.getElementById('mode-indicator');
			if (!modeEl) return;

			// Check last few lines for INSERT mode
			const lines = text.split('\n').slice(-10).join('\n');
			const isInsert = lines.includes('-- INSERT --');

			if (isInsert) {
				modeEl.textContent = 'INS';
				modeEl.className = 'text-xs px-2 py-1 bg-green-600 text-white rounded font-medium shadow-sm';
			} else {
				modeEl.textContent = 'NOR';
				modeEl.className = 'text-xs px-2 py-1 bg-blue-600 text-white rounded font-medium shadow-sm';
			}
		}

		window.toggleMenu = function() {
			document.getElementById('menu').classList.toggle('hidden');
		}

		window.scrollToTop = function() {
			document.getElementById('output-container').scrollTop = 0;
			document.getElementById('menu').classList.add('hidden');
		}

		// Click on prompt pattern to focus input field
		// Detects: ─────── separator lines and > prompt lines
		window.handleOutputClick = function(e) {
			// Don't interfere with text selection
			if (window.getSelection().toString()) return;

			// Get the text at click position
			let clickedLine = '';

			// Try to get the line that was clicked
			if (document.caretRangeFromPoint) {
				const range = document.caretRangeFromPoint(e.clientX, e.clientY);
				if (range && range.startContainer) {
					const text = range.startContainer.textContent || '';
					// Get the line containing the click position
					const lines = text.split('\n');
					let pos = 0;
					for (const line of lines) {
						if (pos + line.length >= range.startOffset) {
							clickedLine = line;
							break;
						}
						pos += line.length + 1;
					}
				}
			}

			// Check if clicked line is a prompt pattern
			const isPromptLine = (
				clickedLine.match(/^\s*>{1,3}\s*/) ||            // > or >>> (with optional text)
				clickedLine.match(/^[─━\-]{5,}/)                 // Separator line (────)
			);

			if (isPromptLine) {
				document.getElementById('input-field').focus();
			}
		}

		// Extract pending input from Claude's prompt line(s)
		// Claude Code shows: ">" or ">>>" followed by user's typed text
		// Multi-line input shows continuation lines after the first prompt
		function extractPendingInput(text) {
			const lines = text.split('\n');
			const pendingLines = [];
			let foundPrompt = false;

			// Scan from bottom up to find prompt area
			for (let i = lines.length - 1; i >= Math.max(0, lines.length - 20); i--) {
				const line = lines[i];

				// Match prompt line: > or >>> with optional text
				const promptMatch = line.match(/^\s*(>{1,3})\s*(.*)$/);

				if (promptMatch) {
					foundPrompt = true;
					const content = promptMatch[2];
					if (content) {
						pendingLines.unshift(content); // Add to front (we're going backwards)
					}
				} else if (foundPrompt) {
					// We found prompts but this line doesn't have one
					const trimmed = line.trim();
					// Stop if we hit a separator, empty line, or status bar content
					if (!trimmed || trimmed.match(/^[─━\-]{5,}/) ||
						trimmed.includes('-- INSERT --') || trimmed.includes('-- NORMAL --')) {
						break;
					}
					// Check if this might be a continuation line (no prompt, just content)
					// Claude wraps long input, so continuation lines are possible
					// But stop if we hit obvious non-prompt content
					if (trimmed.startsWith('│') || trimmed.startsWith('⎿') ||
						trimmed.startsWith('●') || trimmed.startsWith('✻')) {
						break;
					}
					// This could be wrapped input text, add it
					pendingLines.unshift(trimmed);
				}
			}

			if (pendingLines.length === 0) {
				return foundPrompt ? '' : null; // Empty prompt vs no prompt
			}

			return pendingLines.join('\n');
		}

		// Update pending input bar based on output
		function updatePendingInput(text) {
			const pendingBar = document.getElementById('pending-input-bar');
			const pendingText = document.getElementById('pending-input-text');
			if (!pendingBar || !pendingText) return;

			const pending = extractPendingInput(text);
			if (pending && pending.length > 0) {
				// Show first line + indicator if multi-line
				const lines = pending.split('\n');
				let display = lines[0];
				if (lines.length > 1) {
					display += ` (+${lines.length - 1} more)`;
				}
				pendingText.textContent = display;
				pendingText.title = pending; // Full text on hover
				pendingBar.classList.remove('hidden');
			} else {
				pendingBar.classList.add('hidden');
			}
		}

		// Edit pending input - copy to input field for editing
		window.editPendingInput = function() {
			const pendingText = document.getElementById('pending-input-text');
			const inputField = document.getElementById('input-field');
			if (!pendingText || !inputField) return;

			const text = pendingText.textContent;
			if (text) {
				inputField.value = text;
				inputField.focus();
				autoResize(inputField);
				// Clear the existing input in Claude (send Ctrl+U to clear line)
				const bar = document.getElementById('choices-bar');
				const target = bar?.dataset.paneTarget;
				if (target) {
					fetch(`/pane/${target}/send`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
						body: 'input=C-u&special=true'
					});
				}
			}
		}

		// Clear pending input in Claude
		window.clearPendingInput = function() {
			const bar = document.getElementById('choices-bar');
			const target = bar?.dataset.paneTarget;
			if (target) {
				// Send Ctrl+U to clear the line
				fetch(`/pane/${target}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: 'input=C-u&special=true'
				});
			}
		}

		// Toggle auto-accept edits (sends Shift+Tab)
		window.toggleAutoAccept = function() {
			const target = document.getElementById('output-container')?.getAttribute('data-pane-target');
			console.log('toggleAutoAccept called, target:', target);
			if (target) {
				fetch(`/pane/${target}/send`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: 'input=S-Tab&special=true'
				}).then(r => console.log('toggle response:', r.status));
			} else {
				console.warn('No pane target found for toggle');
			}
		}

		// Update Claude mode indicator (dynamic - shows whatever mode is active)
		function updateClaudeMode(mode) {
			const toggle = document.getElementById('autoaccept-toggle');
			const iconEl = toggle?.querySelector('.autoaccept-icon');
			const stateEl = document.getElementById('autoaccept-state');
			if (!toggle || !stateEl || !iconEl) return;

			toggle.classList.remove('on', 'off');
			if (mode.state === 'on') {
				toggle.classList.add('on');
				iconEl.textContent = mode.icon || '⏵⏵';
				stateEl.textContent = 'on';
				toggle.title = `${mode.label || 'Mode'} on (Shift+Tab to cycle)`;
			} else if (mode.state === 'off') {
				toggle.classList.add('off');
				iconEl.textContent = mode.icon || '⏵⏵';
				stateEl.textContent = 'off';
				toggle.title = `${mode.label || 'Mode'} off (Shift+Tab to cycle)`;
			} else {
				// No mode detected
				iconEl.textContent = '⏵⏵';
				stateEl.textContent = '--';
				toggle.title = 'Toggle mode (Shift+Tab)';
			}
		}

		// Toggle status section visibility
		window.toggleStatusSection = function() {
			const section = document.getElementById('status-section');
			const btn = section?.querySelector('.status-toggle-btn');
			const isVisible = section?.classList.contains('visible');

			if (isVisible) {
				section.classList.remove('visible');
				btn.textContent = 'Show';
				localStorage.setItem('statusSectionVisible', 'false');
			} else {
				section.classList.add('visible');
				btn.textContent = 'Hide';
				localStorage.setItem('statusSectionVisible', 'true');
			}
		}

		// Update status line from SSE
		function updateStatusLine(statusLine) {
			const section = document.getElementById('status-section');
			const leftEl = document.getElementById('status-line-left');
			const rightEl = document.getElementById('status-line-right');
			if (!leftEl || !rightEl) return;

			// Strip mode indicators from the end
			let cleaned = statusLine;
			cleaned = cleaned.replace(/\s+--\s+INSERT\s+--.*$/, '');
			cleaned = cleaned.replace(/\s+⏵⏵\s+accept edits.*$/, '');
			cleaned = cleaned.replace(/\s+⏸\s+plan mode.*$/, '');

			// Split at the 🤖 emoji (model info starts)
			const splitIndex = cleaned.indexOf('🤖');
			let leftPart = '';
			let rightPart = '';

			if (splitIndex !== -1) {
				leftPart = cleaned.substring(0, splitIndex).trim();
				rightPart = cleaned.substring(splitIndex).trim();

				// Remove everything after "%" in right part
				const percentIndex = rightPart.indexOf('%');
				if (percentIndex !== -1) {
					rightPart = rightPart.substring(0, percentIndex + 1).trim();
				}
			} else {
				// No split point found, show all as left
				leftPart = cleaned.trim();
			}

			// Display status line parts (ANSI codes preserved)
			leftEl.textContent = leftPart;
			rightEl.textContent = rightPart;

			// Auto-show if status exists and user hasn't hidden it
			if (statusLine && statusLine.trim() !== '') {
				const shouldShow = localStorage.getItem('statusSectionVisible') !== 'false';
				if (shouldShow) {
					section.classList.add('visible');
					section.querySelector('.status-toggle-btn').textContent = 'Hide';
				}
			} else {
				section.classList.remove('visible');
			}
		}

		// Update mode indicators based on current state
		function updateModeIndicators(mode, claudeMode) {
			const acceptEl = document.getElementById('accept-indicator');
			const planEl = document.getElementById('plan-indicator');

			// Accept edits indicator
			if (claudeMode.label === 'accept edits' && claudeMode.state === 'on') {
				acceptEl?.classList.remove('hidden');
			} else {
				acceptEl?.classList.add('hidden');
			}

			// Plan mode indicator
			if (claudeMode.label === 'plan mode' && claudeMode.state === 'on') {
				planEl?.classList.remove('hidden');
			} else {
				planEl?.classList.add('hidden');
			}
		}

		// Cycle Claude modes by sending Shift+Tab to tmux
		window.cycleClaudeMode = function() {
			const paneTarget = document.getElementById('output-container')?.getAttribute('data-pane-target');
			if (!paneTarget) return;

			fetch(`/pane/${paneTarget}/send`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: 'input=S-Tab&special=true'
			}).then(response => {
				if (!response.ok) console.error('Failed to cycle Claude mode');
			});
		}

		// Restore visibility on page load
		document.addEventListener('DOMContentLoaded', function() {
			const shouldShow = localStorage.getItem('statusSectionVisible') !== 'false';
			if (shouldShow) {
				document.getElementById('status-section')?.classList.add('visible');
				const btn = document.querySelector('#status-section .status-toggle-btn');
				if (btn) btn.textContent = 'Hide';
			}
		});

		// Allow Enter to create newlines (for iOS compatibility)
		// Only submit via Send button
		window.handleInputKeydown = function(e) {
			// Cmd/Ctrl+Enter to send (for desktop users who want keyboard shortcut)
			if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
				e.preventDefault();
				document.getElementById('input-form').requestSubmit();
			}
			// Regular Enter creates newline (default behavior for textarea)
		}

		// Auto-resize textarea
		window.autoResize = function(el) {
			el.style.height = 'auto';
			el.style.height = Math.min(el.scrollHeight, 120) + 'px';
		}

		document.addEventListener('click', function(e) {
			const menu = document.getElementById('menu');
			if (!e.target.closest('#menu') && !e.target.closest('[onclick="toggleMenu()"]')) {
				menu.classList.add('hidden');
			}
		});
	</script>
	<script src="/static/app.js"></script>
}

// PaneOutput renders just the pane output (for SSE updates)
templ PaneOutput(output string) {
	{ output }
}
